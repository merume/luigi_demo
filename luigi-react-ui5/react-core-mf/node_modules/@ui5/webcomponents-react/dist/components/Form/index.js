'use client';

import { Device, useSyncRef } from '@ui5/webcomponents-react-base';
import { clsx } from 'clsx';
import React, { Children, cloneElement, forwardRef, useEffect, useMemo, useRef, useState } from 'react';
import { createUseStyles } from 'react-jss';
import { FormBackgroundDesign, TitleLevel } from '../../enums';
import { Title } from '../../webComponents';
import { FormGroupTitle } from '../FormGroup/FormGroupTitle';
import { styles } from './Form.jss';
import { FormContext } from './FormContext';
const useStyles = createUseStyles(styles, {
  name: 'Form'
});
/**
 * The `Form` component arranges labels and fields into groups and rows. There are different ways to visualize forms for different screen sizes.
 * It is possible to change the alignment of all labels by setting the CSS `align-items` property, per default all labels are centered.
 */
const Form = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    as = 'form',
    backgroundDesign = FormBackgroundDesign.Transparent,
    children,
    columnsS = 1,
    columnsM = 1,
    columnsL = 1,
    columnsXL = 2,
    className,
    labelSpanS = 12,
    labelSpanM = 2,
    labelSpanL = 4,
    labelSpanXL = 4,
    titleText,
    style,
    ...rest
  } = props;
  const columnsMap = new Map();
  columnsMap.set('Phone', columnsS);
  columnsMap.set('Tablet', columnsM);
  columnsMap.set('Desktop', columnsL);
  columnsMap.set('LargeDesktop', columnsXL);
  const labelSpanMap = new Map();
  labelSpanMap.set('Phone', labelSpanS);
  labelSpanMap.set('Tablet', labelSpanM);
  labelSpanMap.set('Desktop', labelSpanL);
  labelSpanMap.set('LargeDesktop', labelSpanXL);
  const [componentRef, formRef] = useSyncRef(ref);
  // use the window range set as first best guess, if not available use Desktop
  const [currentRange, setCurrentRange] = useState(Device.getCurrentRange()?.name ?? 'Desktop');
  const lastRange = useRef(currentRange);
  useEffect(() => {
    const observer = new ResizeObserver(_ref => {
      let [form] = _ref;
      const rangeInfo = Device.getCurrentRange(form.contentRect.width);
      if (rangeInfo && lastRange.current !== rangeInfo.name) {
        lastRange.current = rangeInfo.name;
        setCurrentRange(rangeInfo.name);
      }
    });
    if (formRef.current) {
      observer.observe(formRef.current);
    }
    return () => {
      observer.disconnect();
    };
  }, [formRef]);
  const classes = useStyles();
  const currentNumberOfColumns = columnsMap.get(currentRange);
  const currentLabelSpan = labelSpanMap.get(currentRange);
  const formGroups = useMemo(() => {
    if (currentNumberOfColumns === 1) {
      return children;
    }
    const computedFormGroups = [];
    const childrenArray = Children.toArray(children);
    const rows = childrenArray.reduce((acc, val, idx) => {
      const columnIndex = Math.floor(idx / currentNumberOfColumns);
      acc[columnIndex] ??= [];
      acc[columnIndex].push(val);
      return acc;
    }, []);
    const maxRowsPerRow = [];
    rows.forEach((rowGroup, rowIndex) => {
      maxRowsPerRow[rowIndex] = Math.max(...rowGroup.map(row => {
        if (row.type.displayName === 'FormItem') {
          return 1;
        }
        return Children.count(row.props.children) + 1;
      }));
    });
    let totalRowCount = 2;
    rows.forEach((formGroup, rowIndex) => {
      const rowsForThisRow = maxRowsPerRow.at(rowIndex);
      formGroup.forEach((cell, columnIndex) => {
        const titleStyles = {
          gridColumnStart: columnIndex * 12 + 1,
          gridRowStart: totalRowCount
        };
        if (cell?.props?.titleText) {
          computedFormGroups.push( /*#__PURE__*/React.createElement(FormGroupTitle, {
            titleText: cell.props.titleText,
            style: titleStyles,
            key: `title-col-${columnIndex}-row-${totalRowCount}`
          }));
        }
        for (let i = 0; i < rowsForThisRow; i++) {
          let itemToRender;
          if (cell.type.displayName === 'FormGroup') {
            itemToRender = Children.toArray(cell.props.children).at(i);
          } else if (cell.type.displayName === 'FormItem' && i === 0) {
            // render a single FormItem only when index is 0
            itemToRender = cell;
          }
          if (itemToRender) {
            computedFormGroups.push( /*#__PURE__*/cloneElement(itemToRender, {
              key: `col-${columnIndex}-row-${totalRowCount + i}`,
              columnIndex,
              rowIndex: totalRowCount + i + 1
            }));
          }
        }
      });
      totalRowCount += rowsForThisRow;
      if (rowsForThisRow === 1) {
        totalRowCount += 1;
      }
    });
    return computedFormGroups;
  }, [children, currentNumberOfColumns]);
  const formClassNames = clsx(classes.form, classes[backgroundDesign.toLowerCase()]);
  const CustomTag = as;
  return /*#__PURE__*/React.createElement(FormContext.Provider, {
    value: {
      labelSpan: currentLabelSpan
    }
  }, /*#__PURE__*/React.createElement(CustomTag, {
    className: clsx(classes.formContainer, className),
    suppressHydrationWarning: true,
    ref: componentRef,
    style: {
      ...style,
      '--ui5wcr_form_label_span_s': labelSpanS,
      '--ui5wcr_form_label_span_m': labelSpanM,
      '--ui5wcr_form_label_span_l': labelSpanL,
      '--ui5wcr_form_label_span_xl': labelSpanXL,
      '--ui5wcr_form_columns_s': columnsS,
      '--ui5wcr_form_columns_m': columnsM,
      '--ui5wcr_form_columns_l': columnsL,
      '--ui5wcr_form_columns_xl': columnsXL
    },
    ...rest
  }, /*#__PURE__*/React.createElement("div", {
    className: formClassNames
  }, titleText && /*#__PURE__*/React.createElement(Title, {
    level: TitleLevel.H3,
    className: classes.formTitle
  }, titleText), formGroups)));
});
Form.displayName = 'Form';
export { Form };