'use client';

import { debounce, enrichEventWithDetails, ThemingParameters, useSyncRef } from '@ui5/webcomponents-react-base';
import { clsx } from 'clsx';
import React, { cloneElement, forwardRef, useEffect, useRef, useState } from 'react';
import { createUseStyles } from 'react-jss';
import { GlobalStyleClasses, PageBackgroundDesign } from '../../enums';
import { useObserveHeights } from '../../internal/useObserveHeights';
import { DynamicPageAnchorBar } from '../DynamicPageAnchorBar';
import { FlexBox } from '../FlexBox';
import { DynamicPageCssVariables, styles } from './DynamicPage.jss';
import { jsx as _jsx } from "react/jsx-runtime";
import { jsxs as _jsxs } from "react/jsx-runtime";
/**
 * Defines the current state of the component.
 */
var HEADER_STATES = /*#__PURE__*/function (HEADER_STATES) {
  HEADER_STATES["AUTO"] = "AUTO";
  HEADER_STATES["VISIBLE_PINNED"] = "VISIBLE_PINNED";
  HEADER_STATES["HIDDEN_PINNED"] = "HIDDEN_PINNED";
  HEADER_STATES["VISIBLE"] = "VISIBLE";
  HEADER_STATES["HIDDEN"] = "HIDDEN";
  return HEADER_STATES;
}(HEADER_STATES || {});
const useStyles = createUseStyles(styles, {
  name: 'DynamicPage'
});
/**
 * The dynamic page is a generic layout control designed to support various floorplans and use cases.
 * The content of both the header and the page can differ from floorplan to floorplan.
 *
 * The header of the dynamic page is collapsible, which helps users to focus on the actual page content, but still ensures that important header information
 * and actions are readily available.
 */
const DynamicPage = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    headerTitle,
    headerContent,
    style,
    backgroundDesign,
    showHideHeaderButton,
    headerContentPinnable,
    alwaysShowContentHeader,
    children,
    className,
    footer,
    a11yConfig,
    onToggleHeaderContent,
    onPinnedStateChange,
    ...rest
  } = props;
  const {
    onScroll: _1,
    ...propsWithoutOmitted
  } = rest;
  const anchorBarRef = useRef(null);
  const [componentRef, dynamicPageRef] = useSyncRef(ref);
  const contentRef = useRef(null);
  const [componentRefTopHeader, topHeaderRef] = useSyncRef(headerTitle?.ref);
  const [componentRefHeaderContent, headerContentRef] = useSyncRef(headerContent?.ref);
  const scrollTimeout = useRef(0);
  const [headerState, setHeaderState] = useState(alwaysShowContentHeader ? HEADER_STATES.VISIBLE_PINNED : HEADER_STATES.AUTO);
  const isToggledRef = useRef(false);
  const [isOverflowing, setIsOverflowing] = useState(false);
  const [headerCollapsedInternal, setHeaderCollapsedInternal] = useState(undefined);
  // observe heights of header parts
  const {
    topHeaderHeight,
    headerCollapsed
  } = useObserveHeights(dynamicPageRef, topHeaderRef, headerContentRef, anchorBarRef, [headerCollapsedInternal, setHeaderCollapsedInternal], {
    noHeader: false,
    fixedHeader: headerState === HEADER_STATES.VISIBLE_PINNED || headerState === HEADER_STATES.HIDDEN_PINNED,
    scrollTimeout
  });
  const classes = useStyles();
  const dynamicPageClasses = clsx(classes.dynamicPage, GlobalStyleClasses.sapScrollBar, classes[`background${backgroundDesign}`], className, [HEADER_STATES.HIDDEN, HEADER_STATES.HIDDEN_PINNED].includes(headerState) && classes.headerCollapsed);
  useEffect(() => {
    const debouncedObserverFn = debounce(_ref => {
      let [element] = _ref;
      setIsOverflowing(!element.isIntersecting);
    }, 250);
    const observer = new IntersectionObserver(debouncedObserverFn, {
      root: dynamicPageRef.current,
      threshold: 0.98,
      rootMargin: '0px 0px -60px 0px' // negative bottom margin for footer height
    });

    if (contentRef.current) {
      observer.observe(contentRef.current);
    }
    return () => {
      observer.disconnect();
      debouncedObserverFn.cancel();
    };
  }, []);
  useEffect(() => {
    const dynamicPage = dynamicPageRef.current;
    const oneTimeScrollHandler = () => {
      setHeaderState(HEADER_STATES.AUTO);
      setHeaderCollapsedInternal(true);
    };
    if (headerState === HEADER_STATES.VISIBLE || headerState === HEADER_STATES.HIDDEN) {
      dynamicPage?.addEventListener('scroll', oneTimeScrollHandler, {
        once: true
      });
    }
    return () => {
      dynamicPage?.removeEventListener('scroll', oneTimeScrollHandler);
    };
  }, [dynamicPageRef, headerState]);
  const onToggleHeaderContentVisibility = e => {
    scrollTimeout.current = performance.now() + 500;
    const shouldHideHeader = !e.detail.visible;
    setHeaderState(oldState => {
      if (oldState === HEADER_STATES.VISIBLE_PINNED || oldState === HEADER_STATES.HIDDEN_PINNED) {
        return shouldHideHeader ? HEADER_STATES.HIDDEN_PINNED : HEADER_STATES.VISIBLE_PINNED;
      }
      return shouldHideHeader ? HEADER_STATES.HIDDEN : HEADER_STATES.VISIBLE;
    });
  };
  useEffect(() => {
    if (headerState === HEADER_STATES.VISIBLE_PINNED || headerState === HEADER_STATES.VISIBLE) {
      setHeaderCollapsedInternal(false);
    } else if (headerState === HEADER_STATES.HIDDEN_PINNED || headerState === HEADER_STATES.HIDDEN) {
      setHeaderCollapsedInternal(true);
    }
  }, [headerState]);
  const onHoverToggleButton = e => {
    if (topHeaderRef.current) {
      topHeaderRef.current.style.backgroundColor = e?.type === 'mouseover' ? ThemingParameters.sapObjectHeader_Hover_Background : null;
    }
  };
  const onToggleHeaderContentInternal = e => {
    e.stopPropagation();
    if (!isToggledRef.current) {
      isToggledRef.current = true;
    }
    onToggleHeaderContentVisibility(enrichEventWithDetails(e, {
      visible: headerCollapsed
    }));
  };
  const handleHeaderPinnedChange = headerWillPin => {
    if (headerWillPin) {
      setHeaderState(HEADER_STATES.VISIBLE_PINNED);
    } else {
      setHeaderState(HEADER_STATES.VISIBLE);
    }
  };
  useEffect(() => {
    if (alwaysShowContentHeader !== undefined) {
      if (alwaysShowContentHeader) {
        setHeaderState(HEADER_STATES.VISIBLE_PINNED);
      } else {
        setHeaderState(HEADER_STATES.VISIBLE);
      }
    }
  }, [alwaysShowContentHeader]);
  const onDynamicPageScroll = e => {
    if (!isToggledRef.current) {
      isToggledRef.current = true;
    }
    if (typeof props?.onScroll === 'function') {
      props.onScroll(e);
    }
    if (headerState === HEADER_STATES.HIDDEN_PINNED && e.target.scrollTop === 0) {
      setHeaderState(HEADER_STATES.VISIBLE_PINNED);
    }
  };
  const dynamicPageStyles = {
    ...style
  };
  if (headerCollapsed === true && headerContent) {
    scrollTimeout.current = performance.now() + 200;
    dynamicPageStyles[DynamicPageCssVariables.titleFontSize] = ThemingParameters.sapObjectHeader_Title_SnappedFontSize;
  }
  useEffect(() => {
    if (typeof onToggleHeaderContent === 'function' && isToggledRef.current) {
      onToggleHeaderContent(headerCollapsed !== true);
    }
  }, [headerCollapsed]);
  const top = headerState === HEADER_STATES.VISIBLE_PINNED || headerState === HEADER_STATES.VISIBLE ? (headerContentRef?.current?.offsetHeight ?? 0) + topHeaderHeight : topHeaderHeight;
  return /*#__PURE__*/_jsxs("div", {
    ref: componentRef,
    className: dynamicPageClasses,
    style: dynamicPageStyles,
    onScroll: onDynamicPageScroll,
    ...propsWithoutOmitted,
    children: [headerTitle && /*#__PURE__*/cloneElement(headerTitle, {
      'data-not-clickable': alwaysShowContentHeader && !headerContentPinnable || !headerContent || !showHideHeaderButton && !headerContentPinnable,
      ref: componentRefTopHeader,
      className: clsx(classes.title, headerTitle?.props?.className),
      onToggleHeaderContentVisibility: onToggleHeaderContentInternal
    }), headerContent && /*#__PURE__*/cloneElement(headerContent, {
      ref: componentRefHeaderContent,
      style: headerCollapsed === true ? {
        position: 'absolute',
        visibility: 'hidden'
      } : headerContent.props.style,
      className: clsx(classes.header, headerContent?.props?.className),
      headerPinned: headerState === HEADER_STATES.VISIBLE_PINNED || headerState === HEADER_STATES.VISIBLE,
      topHeaderHeight
    }), /*#__PURE__*/_jsx(FlexBox, {
      "data-component-name": "DynamicPageAnchorBarContainer",
      className: classes.anchorBar,
      ref: anchorBarRef,
      style: {
        top
      },
      children: /*#__PURE__*/_jsx(DynamicPageAnchorBar, {
        headerContentPinnable: headerContentPinnable,
        showHideHeaderButton: showHideHeaderButton,
        headerContentVisible: headerContent && headerCollapsed !== true,
        headerPinned: headerState === HEADER_STATES.VISIBLE_PINNED || headerState === HEADER_STATES.HIDDEN_PINNED,
        a11yConfig: a11yConfig,
        onHoverToggleButton: onHoverToggleButton,
        onToggleHeaderContentVisibility: onToggleHeaderContentInternal,
        onPinnedStateChange: onPinnedStateChange,
        setHeaderPinned: handleHeaderPinnedChange
      })
    }), /*#__PURE__*/_jsx("div", {
      ref: contentRef,
      "data-component-name": "DynamicPageContent",
      className: classes.contentContainer,
      style: {
        paddingBlockEnd: footer ? '1rem' : 0
      },
      children: typeof children === 'function' ? children({
        stickyHeaderHeight: top + 1 /*anchorBar height */
      }) : children
    }), footer && /*#__PURE__*/_jsx("div", {
      className: classes.footer,
      style: {
        position: isOverflowing ? 'sticky' : 'absolute'
      },
      "data-component-name": "DynamicPageFooter",
      role: a11yConfig?.dynamicPageFooter?.role ?? 'contentinfo',
      "aria-label": a11yConfig?.dynamicPageFooter?.['aria-label'],
      "aria-labelledby": a11yConfig?.dynamicPageFooter?.['aria-labelledby'],
      children: footer
    })]
  });
});
DynamicPage.displayName = 'DynamicPage';
DynamicPage.defaultProps = {
  backgroundDesign: PageBackgroundDesign.Solid,
  showHideHeaderButton: true,
  headerContentPinnable: true
};
export { DynamicPage };