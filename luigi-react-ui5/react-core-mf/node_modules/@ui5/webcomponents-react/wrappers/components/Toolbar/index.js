'use client';

import { debounce, useI18nBundle, useIsomorphicLayoutEffect, useIsRTL, useSyncRef } from '@ui5/webcomponents-react-base';
import { clsx } from 'clsx';
import React, { Children, cloneElement, createRef, forwardRef, useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { createUseStyles } from 'react-jss';
import { ToolbarDesign, ToolbarStyle } from '../../enums';
import { SHOW_MORE } from '../../i18n/i18n-defaults';
import { flattenFragments } from '../../internal/utils';
import { OverflowPopover } from './OverflowPopover';
import { styles } from './Toolbar.jss';
const useStyles = createUseStyles(styles, {
  name: 'Toolbar'
});
const OVERFLOW_BUTTON_WIDTH = 36 + 8 + 8; // width + padding end + spacing start

/**
 * Horizontal container most commonly used to display buttons, labels, selects and various other input controls.
 *
 * The content of the `Toolbar` moves into the overflow area from right to left when the available space is not enough in the visible area of the container.
 * It can be accessed by the user through the overflow button that opens it in a popover.
 *
 * __Note:__ The overflow popover is mounted only when opened, i.e., any child component of the popover will be remounted, when moved into it.
 */
const Toolbar = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    children,
    toolbarStyle = ToolbarStyle.Standard,
    design = ToolbarDesign.Auto,
    active = false,
    style,
    className,
    onClick,
    slot,
    as = 'div',
    portalContainer,
    numberOfAlwaysVisibleItems = 0,
    onOverflowChange,
    overflowPopoverRef,
    overflowButton,
    ...rest
  } = props;
  const classes = useStyles();
  const [componentRef, outerContainer] = useSyncRef(ref);
  const controlMetaData = useRef([]);
  const [lastVisibleIndex, setLastVisibleIndex] = useState(null);
  const contentRef = useRef(null);
  const overflowContentRef = useRef(null);
  const overflowBtnRef = useRef(null);
  const [minWidth, setMinWidth] = useState('0');
  const isRtl = useIsRTL(outerContainer);
  const i18nBundle = useI18nBundle('@ui5/webcomponents-react');
  const showMoreText = i18nBundle.getText(SHOW_MORE);
  const toolbarClasses = clsx(classes.outerContainer, toolbarStyle === ToolbarStyle.Clear && classes.clear, active && classes.active, design === ToolbarDesign.Solid && classes.solid, design === ToolbarDesign.Transparent && classes.transparent, design === ToolbarDesign.Info && classes.info, className);
  const flatChildren = useMemo(() => {
    return flattenFragments(children, 10);
  }, [children]);
  const childrenWithRef = useMemo(() => {
    controlMetaData.current = [];
    return flatChildren.map((item, index) => {
      const itemRef = /*#__PURE__*/createRef();
      // @ts-expect-error: if type is not defined, it's not a spacer
      const isSpacer = item?.type?.displayName === 'ToolbarSpacer';
      controlMetaData.current.push({
        ref: itemRef,
        isSpacer
      });
      if (isSpacer) {
        return item;
      }
      return /*#__PURE__*/React.createElement("div", {
        ref: itemRef,
        key: index,
        className: classes.childContainer,
        "data-component-name": "ToolbarChildContainer"
      }, item);
    });
  }, [flatChildren, controlMetaData, classes.childContainer]);
  const overflowNeeded = (lastVisibleIndex || lastVisibleIndex === 0) && Children.count(childrenWithRef) !== lastVisibleIndex + 1 && numberOfAlwaysVisibleItems < Children.count(flatChildren);
  useEffect(() => {
    let lastElementResizeObserver;
    const lastElement = contentRef.current.children[numberOfAlwaysVisibleItems - 1];
    const debouncedObserverFn = debounce(() => {
      if (isRtl) {
        setMinWidth(`${lastElement.offsetParent.offsetWidth - lastElement.offsetLeft + OVERFLOW_BUTTON_WIDTH}px`);
      } else {
        setMinWidth(`${lastElement.offsetLeft + lastElement.getBoundingClientRect().width + OVERFLOW_BUTTON_WIDTH}px`);
      }
    }, 200);
    if (numberOfAlwaysVisibleItems && overflowNeeded && lastElement) {
      lastElementResizeObserver = new ResizeObserver(debouncedObserverFn);
      lastElementResizeObserver.observe(contentRef.current);
    }
    return () => {
      debouncedObserverFn.cancel();
      lastElementResizeObserver?.disconnect();
    };
  }, [numberOfAlwaysVisibleItems, overflowNeeded, isRtl]);
  const requestAnimationFrameRef = useRef();
  const calculateVisibleItems = useCallback(() => {
    requestAnimationFrameRef.current = requestAnimationFrame(() => {
      if (!outerContainer.current) return;
      const availableWidth = outerContainer.current.getBoundingClientRect().width;
      let consumedWidth = 0;
      let lastIndex = null;
      if (availableWidth - OVERFLOW_BUTTON_WIDTH <= 0) {
        lastIndex = -1;
      } else {
        let prevItemsAreSpacer = true;
        controlMetaData.current.forEach((item, index) => {
          const currentMeta = controlMetaData.current[index];
          if (currentMeta && currentMeta.ref && currentMeta.ref.current) {
            let nextWidth = currentMeta.ref.current.getBoundingClientRect().width;
            nextWidth += index === 0 || index === controlMetaData.current.length - 1 ? 4 : 8; // first & last element = padding: 4px
            if (index === controlMetaData.current.length - 1) {
              if (consumedWidth + nextWidth <= availableWidth - 8) {
                lastIndex = index;
              } else if (index === 0 || prevItemsAreSpacer) {
                lastIndex = index - 1;
              }
            } else {
              if (consumedWidth + nextWidth <= availableWidth - OVERFLOW_BUTTON_WIDTH) {
                lastIndex = index;
              }
              if (consumedWidth < availableWidth - OVERFLOW_BUTTON_WIDTH && consumedWidth + nextWidth >= availableWidth - OVERFLOW_BUTTON_WIDTH) {
                lastIndex = index - 1;
              }
            }
            if (prevItemsAreSpacer && !item.isSpacer) {
              prevItemsAreSpacer = false;
            }
            consumedWidth += nextWidth;
          }
        });
      }
      setLastVisibleIndex(lastIndex);
    });
  }, [overflowNeeded]);
  useEffect(() => {
    const observer = new ResizeObserver(calculateVisibleItems);
    if (outerContainer.current) {
      observer.observe(outerContainer.current);
    }
    return () => {
      cancelAnimationFrame(requestAnimationFrameRef.current);
      observer.disconnect();
    };
  }, [calculateVisibleItems]);
  useEffect(() => {
    if (Children.count(children) > 0) {
      calculateVisibleItems();
    }
  }, [children]);
  useIsomorphicLayoutEffect(() => {
    calculateVisibleItems();
  }, [calculateVisibleItems]);
  const handleToolbarClick = e => {
    if (active && typeof onClick === 'function') {
      const isSpaceEnterDown = e.type === 'keydown' && (e.code === 'Enter' || e.code === 'Space');
      if (isSpaceEnterDown && e.target !== e.currentTarget) {
        return;
      }
      if (e.type === 'click' || isSpaceEnterDown) {
        e.preventDefault();
        onClick(e);
      }
    }
  };
  const prevChildren = useRef(flatChildren);
  const debouncedOverflowChange = useRef(debounce(onOverflowChange, 60));
  useEffect(() => {
    debouncedOverflowChange.current = debounce(onOverflowChange, 60);
  }, [onOverflowChange]);
  useEffect(() => {
    const haveChildrenChanged = prevChildren.current.length !== flatChildren.length;
    if ((lastVisibleIndex !== null || haveChildrenChanged) && typeof onOverflowChange === 'function') {
      prevChildren.current = flatChildren;
      const toolbarChildren = contentRef.current?.children;
      let toolbarElements = [];
      const overflowElements = overflowContentRef.current?.children;
      if (toolbarChildren?.length > 0) {
        toolbarElements = Array.from(toolbarChildren).filter((item, index) => index <= lastVisibleIndex);
      }
      debouncedOverflowChange.current({
        toolbarElements,
        overflowElements,
        target: outerContainer.current
      });
    }
    return () => {
      debouncedOverflowChange.current.cancel();
    };
  }, [lastVisibleIndex, flatChildren, debouncedOverflowChange]);
  const CustomTag = as;
  const styleWithMinWidth = minWidth !== '0' ? {
    minWidth,
    ...style
  } : style;
  return /*#__PURE__*/React.createElement(CustomTag, {
    style: styleWithMinWidth,
    className: clsx(toolbarClasses, overflowNeeded && classes.hasOverflow),
    ref: componentRef,
    slot: slot,
    onClick: handleToolbarClick,
    onKeyDown: handleToolbarClick,
    tabIndex: active ? 0 : undefined,
    role: active ? 'button' : undefined,
    ...rest
  }, /*#__PURE__*/React.createElement("div", {
    className: classes.toolbar,
    "data-component-name": "ToolbarContent",
    ref: contentRef
  }, overflowNeeded && Children.map(childrenWithRef, (item, index) => {
    if (index >= lastVisibleIndex + 1 && index > numberOfAlwaysVisibleItems - 1) {
      return /*#__PURE__*/cloneElement(item, {
        style: {
          visibility: 'hidden',
          position: 'absolute',
          pointerEvents: 'none'
        }
      });
    }
    return item;
  }), !overflowNeeded && childrenWithRef), overflowNeeded && /*#__PURE__*/React.createElement("div", {
    ref: overflowBtnRef,
    className: classes.overflowButtonContainer,
    "data-component-name": "ToolbarOverflowButtonContainer"
  }, /*#__PURE__*/React.createElement(OverflowPopover, {
    overflowPopoverRef: overflowPopoverRef,
    lastVisibleIndex: lastVisibleIndex,
    classes: classes,
    portalContainer: portalContainer,
    overflowContentRef: overflowContentRef,
    numberOfAlwaysVisibleItems: numberOfAlwaysVisibleItems,
    showMoreText: showMoreText,
    overflowButton: overflowButton
  }, flatChildren)));
});
Toolbar.displayName = 'Toolbar';
export { Toolbar };