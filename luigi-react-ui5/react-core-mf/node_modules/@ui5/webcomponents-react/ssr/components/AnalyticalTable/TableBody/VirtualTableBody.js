import { useVirtualizer } from '@tanstack/react-virtual';
import { clsx } from 'clsx';
import React, { useCallback, useMemo, useRef } from 'react';
import { EmptyRow } from './EmptyRow';
import { RowSubComponent as SubComponent } from './RowSubComponent';
import { jsx as _jsx } from "react/jsx-runtime";
import { createElement as _createElement } from "react";
import { jsxs as _jsxs } from "react/jsx-runtime";
const measureElement = el => el.offsetHeight;
export const VirtualTableBody = props => {
  const {
    alternateRowColor,
    classes,
    prepareRow,
    rows,
    minRows,
    scrollToRef,
    isTreeTable,
    internalRowHeight,
    visibleRows,
    overscanCount,
    visibleColumns,
    parentRef,
    renderRowSubComponent,
    popInRowHeight,
    markNavigatedRow,
    isRtl,
    alwaysShowSubComponent,
    dispatch,
    subComponentsHeight,
    columnVirtualizer
  } = props;
  const itemCount = Math.max(minRows, rows.length);
  const overscan = overscanCount ? overscanCount : Math.floor(visibleRows / 2);
  const rowHeight = popInRowHeight !== internalRowHeight ? popInRowHeight : internalRowHeight;
  const lastNonEmptyRow = useRef(null);
  const rowVirtualizer = useVirtualizer({
    count: itemCount,
    getScrollElement: () => parentRef.current,
    estimateSize: useCallback(index => {
      if (renderRowSubComponent && (rows[index]?.isExpanded || alwaysShowSubComponent) && subComponentsHeight?.[index]?.rowId === rows[index]?.id) {
        return rowHeight + (subComponentsHeight?.[index]?.subComponentHeight ?? 0);
      }
      return rowHeight;
    }, [rowHeight, rows, renderRowSubComponent, alwaysShowSubComponent, subComponentsHeight]),
    overscan,
    measureElement
  });
  scrollToRef.current = {
    ...scrollToRef.current,
    scrollToOffset: rowVirtualizer.scrollToOffset,
    scrollToIndex: rowVirtualizer.scrollToIndex
  };
  const popInColumn = useMemo(() => visibleColumns.filter(item => item.id !== '__ui5wcr__internal_highlight_column' && item.id !== '__ui5wcr__internal_selection_column' && item.id !== '__ui5wcr__internal_navigation_column')[0], [visibleColumns]);
  return /*#__PURE__*/_jsx("div", {
    "data-component-name": "AnalyticalTableBodyScrollableContainer",
    style: {
      position: 'relative',
      height: `${rowVirtualizer.getTotalSize()}px`,
      width: `${columnVirtualizer.getTotalSize()}px`
    },
    children: rowVirtualizer.getVirtualItems().map((virtualRow, visibleRowIndex) => {
      const row = rows[virtualRow.index];
      const rowIndexWithHeader = virtualRow.index + 1;
      if (!row || row.groupByVal === 'undefined') {
        const alternate = alternateRowColor && virtualRow.index % 2 !== 0;
        if (!lastNonEmptyRow.current?.cells) {
          return /*#__PURE__*/_jsx(EmptyRow, {
            virtualRow: virtualRow,
            className: clsx(classes.tr, alternate && classes.alternateRowColor)
          }, `empty_row_${virtualRow.index}`);
        }
        const cells = lastNonEmptyRow.current.cells;
        return /*#__PURE__*/_jsx(EmptyRow, {
          virtualRow: virtualRow,
          className: clsx(classes.tr, alternate && classes.alternateRowColor),
          children: cells.map(item => {
            const cellProps = item.getCellProps();
            const {
              'aria-colindex': _0,
              'aria-selected': _1,
              'aria-label': _2,
              tabIndex: _3,
              ...emptyRowCellProps
            } = cellProps;
            return /*#__PURE__*/_createElement("div", {
              ...emptyRowCellProps,
              key: `${visibleRowIndex}-${emptyRowCellProps.key}`,
              "data-empty-row-cell": "true",
              tabIndex: -1,
              "aria-hidden": true,
              style: {
                ...emptyRowCellProps.style,
                cursor: 'unset'
              }
            });
          })
        }, `empty_row_${virtualRow.index}`);
      } else {
        lastNonEmptyRow.current = row;
      }
      prepareRow(row);
      const rowProps = row.getRowProps();
      const isNavigatedCell = markNavigatedRow(row);
      const RowSubComponent = typeof renderRowSubComponent === 'function' ? renderRowSubComponent(row) : undefined;
      if (!RowSubComponent && subComponentsHeight && subComponentsHeight?.[virtualRow.index]?.subComponentHeight) {
        dispatch({
          type: 'SUB_COMPONENTS_HEIGHT',
          payload: {
            ...subComponentsHeight,
            [virtualRow.index]: {
              subComponentHeight: 0,
              rowId: row.id
            }
          }
        });
      }
      let updatedHeight = rowHeight;
      if (renderRowSubComponent && (rows[virtualRow.index]?.isExpanded || alwaysShowSubComponent) && subComponentsHeight?.[virtualRow.index]?.rowId === rows[virtualRow.index]?.id) {
        updatedHeight += subComponentsHeight?.[virtualRow.index]?.subComponentHeight ?? 0;
      }
      return (
        /*#__PURE__*/
        // eslint-disable-next-line react/jsx-key
        _jsxs("div", {
          ...rowProps,
          style: {
            ...(rowProps.style ?? {}),
            transform: `translateY(${virtualRow.start}px)`,
            position: 'absolute',
            boxSizing: 'border-box',
            height: `${updatedHeight}px`
          },
          ref: node => {
            virtualRow.measureElement(node);
          },
          "aria-rowindex": virtualRow.index + 1,
          children: [RowSubComponent && (row.isExpanded || alwaysShowSubComponent) && /*#__PURE__*/_jsx(SubComponent, {
            subComponentsHeight: subComponentsHeight,
            virtualRow: virtualRow,
            dispatch: dispatch,
            row: row,
            rowHeight: rowHeight,
            rows: rows,
            alwaysShowSubComponent: alwaysShowSubComponent,
            children: RowSubComponent
          }), columnVirtualizer.getVirtualItems().map((virtualColumn, visibleColumnIndex) => {
            const cell = row.cells[virtualColumn.index];
            const directionStyles = isRtl ? {
              transform: `translateX(-${virtualColumn.start}px)`,
              right: 0
            } : {
              transform: `translateX(${virtualColumn.start}px)`,
              left: 0
            };
            if (!cell) {
              return null;
            }
            const cellProps = cell.getCellProps();
            const allCellProps = {
              ...cellProps,
              ['data-visible-column-index']: visibleColumnIndex,
              ['data-column-index']: virtualColumn.index,
              ['data-visible-row-index']: visibleRowIndex + 1,
              ['data-row-index']: rowIndexWithHeader,
              style: {
                ...cellProps.style,
                position: 'absolute',
                width: `${virtualColumn.size}px`,
                top: 0,
                height: `${rowHeight}px`,
                ...directionStyles
              }
            };
            let contentToRender;
            if (cell.column.id === '__ui5wcr__internal_highlight_column' || cell.column.id === '__ui5wcr__internal_selection_column' || cell.column.id === '__ui5wcr__internal_navigation_column') {
              contentToRender = 'Cell';
            } else if (isTreeTable || !alwaysShowSubComponent && RowSubComponent) {
              contentToRender = 'Expandable';
            } else if (cell.isGrouped) {
              contentToRender = 'Grouped';
            } else if (cell.isAggregated) {
              contentToRender = 'Aggregated';
            } else if (cell.isPlaceholder) {
              contentToRender = 'RepeatedValue';
            } else {
              contentToRender = 'Cell';
            }
            return (
              /*#__PURE__*/
              // eslint-disable-next-line react/jsx-key
              _jsx("div", {
                ...allCellProps,
                "data-selection-cell": cell.column.id === '__ui5wcr__internal_selection_column',
                children: popInRowHeight !== internalRowHeight && popInColumn.id === cell.column.id ? cell.render('PopIn', {
                  contentToRender,
                  internalRowHeight
                }) : cell.render(contentToRender, isNavigatedCell === true ? {
                  isNavigatedCell
                } : {})
              })
            );
          })]
        })
      );
    })
  });
};