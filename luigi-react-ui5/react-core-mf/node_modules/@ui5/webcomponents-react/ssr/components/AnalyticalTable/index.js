'use client';

import { useVirtualizer } from '@tanstack/react-virtual';
import { debounce, enrichEventWithDetails, useI18nBundle, useIsomorphicId, useIsomorphicLayoutEffect, useIsRTL } from '@ui5/webcomponents-react-base';
import { clsx } from 'clsx';
import React, { forwardRef, useCallback, useEffect, useMemo, useRef } from 'react';
import { createUseStyles } from 'react-jss';
import { useColumnOrder, useExpanded, useFilters, useGlobalFilter, useGroupBy, useResizeColumns, useRowSelect, useSortBy, useTable } from 'react-table';
import { AnalyticalTableScaleWidthMode, AnalyticalTableSelectionBehavior, AnalyticalTableVisibleRowCountMode, GlobalStyleClasses, AnalyticalTableSelectionMode } from '../../enums';
import { COLLAPSE_NODE, COLLAPSE_PRESS_SPACE, EXPAND_NODE, EXPAND_PRESS_SPACE, FILTERED, GROUPED, INVALID_TABLE, SELECT_PRESS_SPACE, UNSELECT_PRESS_SPACE } from '../../i18n/i18n-defaults';
import { FlexBox } from '../FlexBox';
import { Text } from '../Text';
import styles from './AnayticalTable.jss';
import { ColumnHeaderContainer } from './ColumnHeader/ColumnHeaderContainer';
import { DefaultColumn } from './defaults/Column';
import { DefaultLoadingComponent } from './defaults/LoadingComponent';
import { TablePlaceholder } from './defaults/LoadingComponent/TablePlaceholder';
import { DefaultNoDataComponent } from './defaults/NoDataComponent';
import { useA11y } from './hooks/useA11y';
import { useDragAndDrop } from './hooks/useDragAndDrop';
import { useDynamicColumnWidths } from './hooks/useDynamicColumnWidths';
import { useKeyboardNavigation } from './hooks/useKeyboardNavigation';
import { usePopIn } from './hooks/usePopIn';
import { useResizeColumnsConfig } from './hooks/useResizeColumnsConfig';
import { useRowHighlight } from './hooks/useRowHighlight';
import { useRowNavigationIndicators } from './hooks/useRowNavigationIndicator';
import { useRowSelectionColumn } from './hooks/useRowSelectionColumn';
import { useSelectionChangeCallback } from './hooks/useSelectionChangeCallback';
import { useSingleRowStateSelection } from './hooks/useSingleRowStateSelection';
import { useStyling } from './hooks/useStyling';
import { useTableScrollHandles } from './hooks/useTableScrollHandles';
import { useToggleRowExpand } from './hooks/useToggleRowExpand';
import { useVisibleColumnsWidth } from './hooks/useVisibleColumnsWidth';
import { VerticalScrollbar } from './scrollbars/VerticalScrollbar';
import { VirtualTableBody } from './TableBody/VirtualTableBody';
import { VirtualTableBodyContainer } from './TableBody/VirtualTableBodyContainer';
import { stateReducer } from './tableReducer/stateReducer';
import { TitleBar } from './TitleBar';
import { getRowHeight, tagNamesWhichShouldNotSelectARow } from './util';
import { VerticalResizer } from './VerticalResizer';
import { jsx as _jsx } from "react/jsx-runtime";
import { Fragment as _Fragment } from "react/jsx-runtime";
import { jsxs as _jsxs } from "react/jsx-runtime";
// When a sorted column is removed from the visible columns array (e.g. when "popped-in"), it doesn't clean up the sorted columns leading to an undefined `sortType`.
const sortTypesFallback = {
  undefined: () => undefined
};
const useStyles = createUseStyles(styles, {
  name: 'AnalyticalTable'
});
/**
 * The `AnalyticalTable` provides a set of convenient functions for responsive table design, including virtualization of rows and columns, infinite scrolling and customizable columns that will, unless otherwise defined, distribute the available space equally among themselves.
 * It also provides several possibilities for working with the data, including sorting, filtering, grouping and aggregation.
 */
const AnalyticalTable = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    alternateRowColor,
    alwaysShowSubComponent,
    adjustTableHeightOnPopIn,
    className,
    columnOrder,
    columns,
    data: rawData,
    extension,
    filterable,
    globalFilterValue,
    groupBy,
    groupable,
    header,
    headerRowHeight,
    highlightField,
    infiniteScroll,
    infiniteScrollThreshold,
    isTreeTable,
    loading,
    markNavigatedRow,
    minRows,
    noDataText,
    overscanCount,
    overscanCountHorizontal,
    portalContainer,
    retainColumnWidth,
    reactTableOptions,
    renderRowSubComponent,
    rowHeight,
    scaleWidthMode,
    selectedRowIds,
    selectionBehavior,
    selectionMode,
    showOverlay,
    sortable,
    style,
    subRowsKey,
    tableHooks,
    tableInstance,
    visibleRowCountMode,
    visibleRows,
    withNavigationHighlight,
    withRowHighlight,
    onColumnsReorder,
    onGroup,
    onLoadMore,
    onRowClick,
    onRowExpandChange,
    onRowSelect,
    onSort,
    onTableScroll,
    LoadingComponent,
    NoDataComponent,
    scaleXFactor,
    ...rest
  } = props;
  const uniqueId = useIsomorphicId();
  const i18nBundle = useI18nBundle('@ui5/webcomponents-react');
  const titleBarId = useRef(`titlebar-${uniqueId}`).current;
  const invalidTableTextId = useRef(`invalidTableText-${uniqueId}`).current;
  const classes = useStyles();
  const [analyticalTableRef, scrollToRef] = useTableScrollHandles(ref);
  const tableRef = useRef(null);
  const isRtl = useIsRTL(analyticalTableRef);
  const getSubRows = useCallback(row => row.subRows || row[subRowsKey] || [], [subRowsKey]);
  const invalidTableA11yText = i18nBundle.getText(INVALID_TABLE);
  const tableInstanceRef = useRef(null);
  tableInstanceRef.current = useTable({
    columns,
    data: rawData,
    defaultColumn: DefaultColumn,
    getSubRows,
    stateReducer,
    disableFilters: !filterable,
    disableSortBy: !sortable,
    disableGroupBy: isTreeTable || renderRowSubComponent ? true : !groupable,
    selectSubRows: false,
    sortTypes: sortTypesFallback,
    webComponentsReactProperties: {
      translatableTexts: {
        expandA11yText: i18nBundle.getText(EXPAND_PRESS_SPACE),
        collapseA11yText: i18nBundle.getText(COLLAPSE_PRESS_SPACE),
        selectA11yText: i18nBundle.getText(SELECT_PRESS_SPACE),
        unselectA11yText: i18nBundle.getText(UNSELECT_PRESS_SPACE),
        expandNodeA11yText: i18nBundle.getText(EXPAND_NODE),
        collapseNodeA11yText: i18nBundle.getText(COLLAPSE_NODE),
        filteredA11yText: i18nBundle.getText(FILTERED),
        groupedA11yText: i18nBundle.getText(GROUPED)
      },
      tagNamesWhichShouldNotSelectARow,
      tableRef,
      selectionMode,
      selectionBehavior,
      classes,
      onRowSelect: onRowSelect,
      onRowClick,
      onRowExpandChange,
      isTreeTable,
      alternateRowColor,
      scaleWidthMode,
      loading,
      withRowHighlight,
      highlightField,
      withNavigationHighlight,
      markNavigatedRow,
      renderRowSubComponent,
      alwaysShowSubComponent,
      scrollToRef,
      showOverlay,
      uniqueId,
      scaleXFactor
    },
    ...reactTableOptions
  }, useFilters, useGlobalFilter, useColumnOrder, useGroupBy, useSortBy, useExpanded, useRowSelect, useResizeColumns, useResizeColumnsConfig, useRowSelectionColumn, useSingleRowStateSelection, useSelectionChangeCallback, useRowHighlight, useRowNavigationIndicators, useDynamicColumnWidths, useStyling, useToggleRowExpand, useA11y, usePopIn, useVisibleColumnsWidth, useKeyboardNavigation, ...tableHooks);
  const {
    getTableProps,
    headerGroups,
    rows,
    prepareRow,
    state: tableState,
    columns: tableInternalColumns,
    setColumnOrder,
    dispatch,
    totalColumnsWidth,
    visibleColumns,
    visibleColumnsWidth,
    setGroupBy,
    setGlobalFilter
  } = tableInstanceRef.current;
  if (tableInstance && {}.hasOwnProperty.call(tableInstance, 'current')) {
    tableInstance.current = tableInstanceRef.current;
  }
  if (typeof tableInstance === 'function') {
    tableInstance(tableInstanceRef.current);
  }
  const titleBarRef = useRef(null);
  const extensionRef = useRef(null);
  const headerRef = useRef(null);
  const extensionsHeight = (titleBarRef.current?.offsetHeight ?? 0) + (extensionRef.current?.offsetHeight ?? 0) + (headerRef.current?.offsetHeight ?? 0);
  const internalRowHeight = getRowHeight(rowHeight, tableRef);
  const internalHeaderRowHeight = headerRowHeight ?? internalRowHeight;
  const popInRowHeight = tableState?.popInColumns?.length > 0 ? internalRowHeight + tableState.popInColumns.length * (internalRowHeight + 16) : internalRowHeight;
  const internalVisibleRowCount = tableState.visibleRows ?? visibleRows;
  const updateTableClientWidth = useCallback(() => {
    if (tableRef.current) {
      dispatch({
        type: 'TABLE_RESIZE',
        payload: {
          tableClientWidth: tableRef.current.clientWidth
        }
      });
    }
  }, [tableRef.current]);
  const updateRowsCount = useCallback(() => {
    if (visibleRowCountMode === AnalyticalTableVisibleRowCountMode.Auto && analyticalTableRef.current?.parentElement) {
      const parentElement = analyticalTableRef.current?.parentElement;
      const tableYPosition = parentElement && getComputedStyle(parentElement).position === 'relative' && analyticalTableRef.current?.offsetTop ? analyticalTableRef.current?.offsetTop : 0;
      const parentHeight = parentElement?.getBoundingClientRect().height;
      const tableHeight = parentHeight ? parentHeight - tableYPosition : 0;
      const rowCount = Math.max(1, Math.floor((tableHeight - extensionsHeight) / popInRowHeight));
      dispatch({
        type: 'VISIBLE_ROWS',
        payload: {
          visibleRows: rowCount
        }
      });
    }
  }, [analyticalTableRef.current?.parentElement?.getBoundingClientRect().height, analyticalTableRef.current?.getBoundingClientRect().y, extensionsHeight, popInRowHeight, visibleRowCountMode]);
  useEffect(() => {
    setGlobalFilter(globalFilterValue);
  }, [globalFilterValue, setGlobalFilter]);
  useEffect(() => {
    const debouncedWidthObserverFn = debounce(updateTableClientWidth, 60);
    const tableWidthObserver = new ResizeObserver(debouncedWidthObserverFn);
    tableWidthObserver.observe(tableRef.current);
    const debouncedHeightObserverFn = debounce(updateRowsCount, 60);
    const parentHeightObserver = new ResizeObserver(debouncedHeightObserverFn);
    if (analyticalTableRef.current?.parentElement) {
      parentHeightObserver.observe(analyticalTableRef.current?.parentElement);
    }
    return () => {
      debouncedHeightObserverFn.cancel();
      debouncedWidthObserverFn.cancel();
      tableWidthObserver.disconnect();
      parentHeightObserver.disconnect();
    };
  }, [updateTableClientWidth, updateRowsCount]);
  useIsomorphicLayoutEffect(() => {
    dispatch({
      type: 'IS_RTL',
      payload: {
        isRtl
      }
    });
  }, [isRtl]);
  useIsomorphicLayoutEffect(() => {
    updateTableClientWidth();
  }, [updateTableClientWidth]);
  useIsomorphicLayoutEffect(() => {
    updateRowsCount();
  }, [updateRowsCount]);
  useEffect(() => {
    if (tableState.visibleRows !== undefined && visibleRowCountMode === AnalyticalTableVisibleRowCountMode.Fixed) {
      dispatch({
        type: 'VISIBLE_ROWS',
        payload: {
          visibleRows: undefined
        }
      });
    }
  }, [visibleRowCountMode, tableState.visibleRows]);
  useEffect(() => {
    setGroupBy(groupBy);
  }, [groupBy, setGroupBy]);
  useEffect(() => {
    dispatch({
      type: 'SET_SELECTED_ROW_IDS',
      payload: {
        selectedRowIds
      }
    });
  }, [selectedRowIds]);
  useEffect(() => {
    if (tableState?.interactiveRowsHavePopIn && (!tableState?.popInColumns || tableState?.popInColumns?.length === 0)) {
      dispatch({
        type: 'WITH_POPIN',
        payload: false
      });
    }
  }, [tableState?.interactiveRowsHavePopIn, tableState?.popInColumns?.length]);
  const tableBodyHeight = useMemo(() => {
    const rowNum = rows.length < internalVisibleRowCount ? Math.max(rows.length, minRows) : internalVisibleRowCount;
    const rowHeight = visibleRowCountMode === AnalyticalTableVisibleRowCountMode.Auto || tableState?.interactiveRowsHavePopIn || adjustTableHeightOnPopIn ? popInRowHeight : internalRowHeight;
    return rowHeight * rowNum;
  }, [internalRowHeight, rows.length, internalVisibleRowCount, minRows, popInRowHeight, visibleRowCountMode, tableState?.interactiveRowsHavePopIn, adjustTableHeightOnPopIn]);

  // scroll bar detection
  useEffect(() => {
    const visibleRowCount = rows.length < internalVisibleRowCount ? Math.max(rows.length, minRows) : internalVisibleRowCount;
    if (popInRowHeight !== internalRowHeight) {
      dispatch({
        type: 'TABLE_SCROLLING_ENABLED',
        payload: {
          isScrollable: visibleRowCount * popInRowHeight > tableBodyHeight || rows.length > visibleRowCount
        }
      });
    } else {
      dispatch({
        type: 'TABLE_SCROLLING_ENABLED',
        payload: {
          isScrollable: rows.length > visibleRowCount
        }
      });
    }
  }, [rows.length, minRows, internalVisibleRowCount, popInRowHeight, tableBodyHeight]);
  const noDataStyles = {
    height: `${tableBodyHeight}px`,
    width: totalColumnsWidth ? `${totalColumnsWidth}px` : '100%'
  };
  const onGroupByChanged = useCallback(e => {
    const {
      column,
      isGrouped
    } = e.detail;
    let groupedColumns = [];
    if (isGrouped) {
      groupedColumns = [...tableState.groupBy, column.id];
    } else {
      groupedColumns = tableState.groupBy.filter(group => group !== column.id);
    }
    setGroupBy(groupedColumns);
    onGroup(enrichEventWithDetails(e, {
      column,
      groupedColumns
    }));
  }, [tableState.groupBy, onGroup, setGroupBy]);
  useEffect(() => {
    if (columnOrder?.length > 0) {
      setColumnOrder(columnOrder);
    }
  }, [columnOrder]);
  const [dragOver, handleDragEnter, handleDragStart, handleDragOver, handleOnDrop, handleOnDragEnd] = useDragAndDrop(isRtl, setColumnOrder, tableState.columnOrder, tableState.columnResizing, tableInternalColumns, onColumnsReorder);
  const inlineStyle = useMemo(() => {
    const tableStyles = {
      maxWidth: '100%',
      overflowX: 'auto',
      display: 'flex',
      flexDirection: 'column'
    };
    if (!!rowHeight) {
      tableStyles['--sapWcrAnalyticalTableRowHeight'] = `${rowHeight}px`;
      tableStyles['--sapWcrAnalyticalTableHeaderRowHeight'] = `${rowHeight}px`;
    }
    if (!!headerRowHeight) {
      tableStyles['--sapWcrAnalyticalTableHeaderRowHeight'] = `${headerRowHeight}px`;
    }
    if (tableState.tableClientWidth > 0) {
      return {
        ...tableStyles,
        ...style
      };
    }
    return {
      ...tableStyles,
      ...style,
      visibility: 'hidden'
    };
  }, [tableState.tableClientWidth, style, rowHeight, headerRowHeight]);
  useEffect(() => {
    if (retainColumnWidth && tableState.columnResizing?.isResizingColumn && tableState.tableColResized == null) {
      dispatch({
        type: 'TABLE_COL_RESIZED',
        payload: true
      });
    }
    if (tableState.tableColResized && !retainColumnWidth) {
      dispatch({
        type: 'TABLE_COL_RESIZED',
        payload: undefined
      });
    }
  }, [tableState.columnResizing, retainColumnWidth, tableState.tableColResized]);
  const parentRef = useRef(null);
  const verticalScrollBarRef = useRef(null);
  const handleBodyScroll = e => {
    if (typeof onTableScroll === 'function') {
      onTableScroll(e);
    }
    if (verticalScrollBarRef.current && verticalScrollBarRef.current.scrollTop !== parentRef.current.scrollTop) {
      if (!parentRef.current.isExternalVerticalScroll) {
        verticalScrollBarRef.current.scrollTop = parentRef.current.scrollTop;
        verticalScrollBarRef.current.isExternalVerticalScroll = true;
      }
      parentRef.current.isExternalVerticalScroll = false;
    }
  };
  const handleVerticalScrollBarScroll = () => {
    if (!verticalScrollBarRef.current.isExternalVerticalScroll) {
      parentRef.current.scrollTop = verticalScrollBarRef.current.scrollTop;
      parentRef.current.isExternalVerticalScroll = true;
    }
    verticalScrollBarRef.current.isExternalVerticalScroll = false;
  };
  const tableClasses = clsx(classes.table, GlobalStyleClasses.sapScrollBar, withNavigationHighlight && classes.hasNavigationIndicator);
  const columnVirtualizer = useVirtualizer({
    count: visibleColumnsWidth.length,
    getScrollElement: () => tableRef.current,
    estimateSize: useCallback(index => {
      return visibleColumnsWidth[index];
    }, [visibleColumnsWidth]),
    horizontal: true,
    overscan: overscanCountHorizontal
  });
  scrollToRef.current = {
    ...scrollToRef.current,
    horizontalScrollToOffset: columnVirtualizer.scrollToOffset,
    horizontalScrollToIndex: columnVirtualizer.scrollToIndex
  };
  return /*#__PURE__*/_jsxs(_Fragment, {
    children: [/*#__PURE__*/_jsxs("div", {
      className: className,
      style: inlineStyle,
      ref: analyticalTableRef,
      ...rest,
      children: [header && /*#__PURE__*/_jsx(TitleBar, {
        ref: titleBarRef,
        titleBarId: titleBarId,
        children: header
      }), extension && /*#__PURE__*/_jsx("div", {
        ref: extensionRef,
        children: extension
      }), /*#__PURE__*/_jsxs(FlexBox, {
        className: classes.tableContainerWithScrollBar,
        "data-component-name": "AnalyticalTableContainerWithScrollbar",
        children: [showOverlay && /*#__PURE__*/_jsxs(_Fragment, {
          children: [/*#__PURE__*/_jsx("span", {
            id: invalidTableTextId,
            className: classes.hiddenA11yText,
            "aria-hidden": true,
            children: invalidTableA11yText
          }), /*#__PURE__*/_jsx("div", {
            tabIndex: 0,
            "aria-labelledby": `${titleBarId} ${invalidTableTextId}`,
            role: "region",
            "data-component-name": "AnalyticalTableOverlay",
            className: classes.overlay
          })]
        }), /*#__PURE__*/_jsxs("div", {
          "aria-labelledby": titleBarId,
          ...getTableProps(),
          tabIndex: showOverlay ? -1 : 0,
          role: "grid",
          "aria-rowcount": rows.length,
          "aria-colcount": visibleColumns.length,
          "data-per-page": internalVisibleRowCount,
          "data-component-name": "AnalyticalTableContainer",
          ref: tableRef,
          "data-native-scrollbar": props['data-native-scrollbar'],
          className: tableClasses,
          children: [/*#__PURE__*/_jsx("div", {
            className: classes.tableHeaderBackgroundElement
          }), /*#__PURE__*/_jsx("div", {
            className: classes.tableBodyBackgroundElement
          }), headerGroups.map(headerGroup => {
            let headerProps = {};
            if (headerGroup.getHeaderGroupProps) {
              headerProps = headerGroup.getHeaderGroupProps();
            }
            return tableRef.current && /*#__PURE__*/_jsx(ColumnHeaderContainer, {
              ref: headerRef,
              resizeInfo: tableState.columnResizing,
              headerProps: headerProps,
              headerGroup: headerGroup,
              onSort: onSort,
              onGroupByChanged: onGroupByChanged,
              onDragStart: handleDragStart,
              onDragOver: handleDragOver,
              onDrop: handleOnDrop,
              onDragEnter: handleDragEnter,
              onDragEnd: handleOnDragEnd,
              dragOver: dragOver,
              isRtl: isRtl,
              portalContainer: portalContainer,
              columnVirtualizer: columnVirtualizer,
              scaleXFactor: scaleXFactor,
              uniqueId: uniqueId
            }, headerProps.key);
          }), loading && rawData?.length > 0 && /*#__PURE__*/_jsx(LoadingComponent, {
            style: {
              width: `${totalColumnsWidth}px`
            }
          }), loading && rawData?.length === 0 && /*#__PURE__*/_jsx(TablePlaceholder, {
            columns: visibleColumns,
            rows: minRows,
            style: noDataStyles
          }), !loading && rawData?.length === 0 && /*#__PURE__*/_jsx(NoDataComponent, {
            noDataText: noDataText,
            className: classes.noDataContainer,
            style: noDataStyles
          }), rawData?.length > 0 && tableRef.current && /*#__PURE__*/_jsx(VirtualTableBodyContainer, {
            rowCollapsedFlag: tableState.rowCollapsed,
            dispatch: dispatch,
            tableBodyHeight: tableBodyHeight,
            totalColumnsWidth: totalColumnsWidth,
            parentRef: parentRef,
            classes: classes,
            infiniteScroll: infiniteScroll,
            infiniteScrollThreshold: infiniteScrollThreshold,
            onLoadMore: onLoadMore,
            internalRowHeight: internalRowHeight,
            popInRowHeight: popInRowHeight,
            rows: rows,
            handleExternalScroll: handleBodyScroll,
            visibleRows: internalVisibleRowCount,
            children: /*#__PURE__*/_jsx(VirtualTableBody, {
              classes: classes,
              prepareRow: prepareRow,
              rows: rows,
              minRows: minRows,
              scrollToRef: scrollToRef,
              isTreeTable: isTreeTable,
              internalRowHeight: internalRowHeight,
              popInRowHeight: popInRowHeight,
              visibleRows: internalVisibleRowCount,
              alternateRowColor: alternateRowColor,
              overscanCount: overscanCount,
              parentRef: parentRef,
              visibleColumns: visibleColumns,
              renderRowSubComponent: renderRowSubComponent,
              alwaysShowSubComponent: alwaysShowSubComponent,
              markNavigatedRow: markNavigatedRow,
              isRtl: isRtl,
              subComponentsHeight: tableState.subComponentsHeight,
              dispatch: dispatch,
              columnVirtualizer: columnVirtualizer
            })
          })]
        }), (tableState.isScrollable === undefined || tableState.isScrollable) && /*#__PURE__*/_jsx(VerticalScrollbar, {
          tableBodyHeight: tableBodyHeight,
          internalRowHeight: internalHeaderRowHeight,
          popInRowHeight: popInRowHeight,
          tableRef: tableRef,
          minRows: minRows,
          rows: rows,
          handleVerticalScrollBarScroll: handleVerticalScrollBarScroll,
          ref: verticalScrollBarRef,
          "data-native-scrollbar": props['data-native-scrollbar']
        })]
      }), visibleRowCountMode === AnalyticalTableVisibleRowCountMode.Interactive && /*#__PURE__*/_jsx(VerticalResizer, {
        popInRowHeight: popInRowHeight,
        hasPopInColumns: tableState?.popInColumns?.length > 0,
        analyticalTableRef: analyticalTableRef,
        dispatch: dispatch,
        extensionsHeight: extensionsHeight,
        internalRowHeight: internalRowHeight,
        portalContainer: portalContainer
      })]
    }), /*#__PURE__*/_jsx(Text, {
      "aria-hidden": "true",
      id: `smartScaleModeHelper-${uniqueId}`,
      className: classes.hiddenSmartColMeasure,
      children: ''
    })]
  });
});
AnalyticalTable.displayName = 'AnalyticalTable';
AnalyticalTable.defaultProps = {
  infiniteScrollThreshold: 20,
  loading: false,
  sortable: true,
  filterable: false,
  groupable: false,
  selectionMode: AnalyticalTableSelectionMode.None,
  selectionBehavior: AnalyticalTableSelectionBehavior.Row,
  scaleWidthMode: AnalyticalTableScaleWidthMode.Default,
  data: [],
  columns: [],
  minRows: 5,
  groupBy: [],
  NoDataComponent: DefaultNoDataComponent,
  LoadingComponent: DefaultLoadingComponent,
  noDataText: 'No Data',
  reactTableOptions: {},
  tableHooks: [],
  visibleRows: 15,
  subRowsKey: 'subRows',
  highlightField: 'status',
  markNavigatedRow: () => false,
  selectedRowIds: {},
  onGroup: () => {},
  onRowExpandChange: () => {},
  isTreeTable: false,
  alternateRowColor: false,
  overscanCountHorizontal: 5,
  visibleRowCountMode: AnalyticalTableVisibleRowCountMode.Fixed,
  alwaysShowSubComponent: false
};
export { AnalyticalTable };