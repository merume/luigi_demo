import { getEffectiveScopingSuffixForTag } from '@ui5/webcomponents-base/dist/CustomElementsScope.js';
import { useIsomorphicLayoutEffect, useSyncRef } from '@ui5/webcomponents-react-base';
import React, { Children, cloneElement, forwardRef, Fragment, useEffect, useState } from 'react';
import { camelToKebabCase, capitalizeFirstLetter, kebabToCamelCase } from './utils';
const createEventPropName = eventName => `on${capitalizeFirstLetter(kebabToCamelCase(eventName))}`;
const definedWebComponents = new Set([]);
export const withWebComponent = (tagName, regularProperties, booleanProperties, slotProperties, eventProperties, loader) => {
  // displayName will be assigned in the individual files
  // eslint-disable-next-line react/display-name
  return /*#__PURE__*/forwardRef((props, wcRef) => {
    const {
      className,
      children,
      waitForDefine,
      ...rest
    } = props;
    const [componentRef, ref] = useSyncRef(wcRef);
    const tagNameSuffix = getEffectiveScopingSuffixForTag(tagName);
    const Component = tagNameSuffix ? `${tagName}-${tagNameSuffix}` : tagName;
    const [isDefined, setIsDefined] = useState(definedWebComponents.has(Component));
    // regular props (no booleans, no slots and no events)
    const regularProps = regularProperties.reduce((acc, name) => {
      if (rest.hasOwnProperty(name)) {
        return {
          ...acc,
          [camelToKebabCase(name)]: rest[name]
        };
      }
      return acc;
    }, {});

    // boolean properties - only attach if they are truthy
    const booleanProps = booleanProperties.reduce((acc, name) => {
      if (rest[name] === true || rest[name] === 'true') {
        return {
          ...acc,
          [camelToKebabCase(name)]: true
        };
      }
      return acc;
    }, {});
    const slots = slotProperties.reduce((acc, name) => {
      const slotValue = rest[name];
      if (!slotValue) {
        return acc;
      }
      if (rest[name]?.$$typeof === Symbol.for('react.portal')) {
        console.warn('ReactPortal is not supported for slot props.');
        return acc;
      }
      const slottedChildren = [];
      let index = 0;
      const removeFragments = element => {
        if (!element) return;
        if (element.type === Fragment) {
          Children.toArray(element.props?.children).filter(Boolean).forEach(item => {
            removeFragments(item);
          });
        } else {
          slottedChildren.push( /*#__PURE__*/cloneElement(element, {
            key: `${name}-${index}`,
            slot: name
          }));
          index++;
        }
      };
      if (Array.isArray(slotValue)) {
        slotValue.forEach(item => {
          removeFragments(item);
        });
      } else {
        removeFragments(slotValue);
      }
      return [...acc, ...slottedChildren];
    }, []);

    // event binding
    useIsomorphicLayoutEffect(() => {
      const localRef = ref.current;
      const eventRegistry = {};
      if (!waitForDefine || isDefined) {
        eventProperties.forEach(eventName => {
          const eventHandler = rest[createEventPropName(eventName)];
          if (typeof eventHandler === 'function') {
            eventRegistry[eventName] = eventHandler;
            // @ts-expect-error: all custom events can be passed here, so `keyof HTMLElementEventMap` isn't sufficient
            localRef?.addEventListener(eventName, eventRegistry[eventName]);
          }
        });
        return () => {
          for (const eventName in eventRegistry) {
            // @ts-expect-error: all custom events can be passed here, so `keyof HTMLElementEventMap` isn't sufficient
            localRef?.removeEventListener(eventName, eventRegistry[eventName]);
          }
        };
      }
    }, [...eventProperties.map(eventName => rest[createEventPropName(eventName)]), isDefined, waitForDefine]);

    // non web component related props, just pass them
    const nonWebComponentRelatedProps = Object.entries(rest).filter(_ref => {
      let [key] = _ref;
      return !regularProperties.includes(key);
    }).filter(_ref2 => {
      let [key] = _ref2;
      return !slotProperties.includes(key);
    }).filter(_ref3 => {
      let [key] = _ref3;
      return !booleanProperties.includes(key);
    }).filter(_ref4 => {
      let [key] = _ref4;
      return !eventProperties.map(eventName => createEventPropName(eventName)).includes(key);
    }).reduce((acc, _ref5) => {
      let [key, val] = _ref5;
      return {
        ...acc,
        [key]: val
      };
    }, {});
    useEffect(() => {
      if (waitForDefine && !isDefined) {
        customElements.whenDefined(Component).then(() => {
          setIsDefined(true);
          definedWebComponents.add(Component);
        });
      }
    }, [Component, waitForDefine, isDefined]);
    if (waitForDefine && !isDefined) {
      return null;
    }
    return /*#__PURE__*/React.createElement(Component, {
      ref: componentRef,
      ...booleanProps,
      ...regularProps,
      ...nonWebComponentRelatedProps,
      class: className
    }, slots, children);
  });
};