'use client';

import { debounce, enrichEventWithDetails, ThemingParameters, useSyncRef } from '@ui5/webcomponents-react-base';
import { clsx } from 'clsx';
import React, { cloneElement, forwardRef, isValidElement, useCallback, useEffect, useMemo, useRef, useState } from 'react';
import { createUseStyles } from 'react-jss';
import { AvatarSize, GlobalStyleClasses, ObjectPageMode } from '../../enums';
import { addCustomCSSWithScoping } from '../../internal/addCustomCSSWithScoping';
import { safeGetChildrenArray } from '../../internal/safeGetChildrenArray';
import { useObserveHeights } from '../../internal/useObserveHeights';
import { Tab, TabContainer } from '../../webComponents';
import { DynamicPageCssVariables } from '../DynamicPage/DynamicPage.jss';
import { DynamicPageAnchorBar } from '../DynamicPageAnchorBar';
import { CollapsedAvatar } from './CollapsedAvatar';
import { styles } from './ObjectPage.jss';
import { extractSectionIdFromHtmlId, getSectionById } from './ObjectPageUtils';
addCustomCSSWithScoping('ui5-tabcontainer',
// padding-inline is used here to ensure the same responsive padding behavior as for the rest of the component
`
  :host([data-component-name="ObjectPageTabContainer"]) .ui5-tc__header {
    padding: 0;
    padding-inline: var(--_ui5wcr_ObjectPage_tab_bar_inline_padding);
    box-shadow: inset 0 -0.0625rem ${ThemingParameters.sapPageHeader_BorderColor}, 0 0.125rem 0.25rem 0 rgb(0 0 0 / 8%);
  }
  `);
const useStyles = createUseStyles(styles, {
  name: 'ObjectPage'
});

/**
 * A component that allows apps to easily display information related to a business object.
 *
 * The `ObjectPage` is composed of a header (title and content) and block content wrapped in sections and subsections that structure the information.
 */
const ObjectPage = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    headerTitle,
    image,
    footer,
    mode,
    imageShapeCircle,
    className,
    style,
    slot,
    showHideHeaderButton,
    children,
    selectedSectionId,
    alwaysShowContentHeader,
    showTitleInHeaderContent,
    headerContent,
    headerContentPinnable,
    a11yConfig,
    placeholder,
    onSelectedSectionChange,
    onToggleHeaderContent,
    onPinnedStateChange,
    ...rest
  } = props;
  const classes = useStyles();
  const firstSectionId = safeGetChildrenArray(children)[0]?.props?.id;
  const [internalSelectedSectionId, setInternalSelectedSectionId] = useState(selectedSectionId ?? firstSectionId);
  const [selectedSubSectionId, setSelectedSubSectionId] = useState(props.selectedSubSectionId);
  const [headerPinned, setHeaderPinned] = useState(alwaysShowContentHeader);
  const isProgrammaticallyScrolled = useRef(false);
  const [componentRef, objectPageRef] = useSyncRef(ref);
  const topHeaderRef = useRef(null);
  const scrollEvent = useRef();
  // @ts-expect-error: useSyncRef will create a ref if not present
  const [componentRefHeaderContent, headerContentRef] = useSyncRef(headerContent?.ref);
  const anchorBarRef = useRef(null);
  const selectionScrollTimeout = useRef(null);
  const [isAfterScroll, setIsAfterScroll] = useState(false);
  const isToggledRef = useRef(false);
  const [headerCollapsedInternal, setHeaderCollapsedInternal] = useState(undefined);
  const [scrolledHeaderExpanded, setScrolledHeaderExpanded] = useState(false);
  const scrollTimeout = useRef(0);
  const [spacerBottomHeight, setSpacerBottomHeight] = useState('0px');
  const prevInternalSelectedSectionId = useRef(internalSelectedSectionId);
  const fireOnSelectedChangedEvent = (targetEvent, index, id, section) => {
    if (typeof onSelectedSectionChange === 'function' && prevInternalSelectedSectionId.current !== id) {
      onSelectedSectionChange(enrichEventWithDetails(targetEvent, {
        selectedSectionIndex: parseInt(index, 10),
        selectedSectionId: id,
        section
      }));
      prevInternalSelectedSectionId.current = id;
    }
  };
  const debouncedOnSectionChange = useRef(debounce(fireOnSelectedChangedEvent, 500)).current;
  useEffect(() => {
    return () => {
      debouncedOnSectionChange.cancel();
      clearTimeout(selectionScrollTimeout.current);
    };
  }, []);

  // observe heights of header parts
  const {
    topHeaderHeight,
    headerContentHeight,
    anchorBarHeight,
    totalHeaderHeight,
    headerCollapsed
  } = useObserveHeights(objectPageRef, topHeaderRef, headerContentRef, anchorBarRef, [headerCollapsedInternal, setHeaderCollapsedInternal], {
    noHeader: !headerTitle && !headerContent,
    fixedHeader: headerPinned,
    scrollTimeout
  });
  useEffect(() => {
    if (typeof onToggleHeaderContent === 'function' && isToggledRef.current) {
      onToggleHeaderContent(headerCollapsed !== true);
    }
  }, [headerCollapsed]);
  const avatar = useMemo(() => {
    if (!image) {
      return null;
    }
    if (typeof image === 'string') {
      return /*#__PURE__*/React.createElement("span", {
        className: classes.headerImage,
        style: {
          borderRadius: imageShapeCircle ? '50%' : 0,
          overflow: 'hidden'
        }
      }, /*#__PURE__*/React.createElement("img", {
        src: image,
        className: classes.image,
        alt: "Company Logo"
      }));
    } else {
      return /*#__PURE__*/cloneElement(image, {
        size: AvatarSize.L,
        className: clsx(classes.headerImage, image.props?.className)
      });
    }
  }, [image, classes.headerImage, classes.image, imageShapeCircle]);
  const prevTopHeaderHeight = useRef(0);
  const scrollToSection = useCallback(sectionId => {
    if (!sectionId) {
      return;
    }
    if (firstSectionId === sectionId) {
      objectPageRef.current?.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    } else {
      const childOffset = objectPageRef.current?.querySelector(`#ObjectPageSection-${sectionId}`)?.offsetTop;
      if (!isNaN(childOffset)) {
        const safeTopHeaderHeight = topHeaderHeight || prevTopHeaderHeight.current;
        if (topHeaderHeight) {
          prevTopHeaderHeight.current = topHeaderHeight;
        }
        objectPageRef.current?.scrollTo({
          top: childOffset - safeTopHeaderHeight - anchorBarHeight - 48 /*tabBar*/ - (headerPinned ? headerCollapsed === true ? 0 : headerContentHeight : 0),
          behavior: 'smooth'
        });
      }
    }
    isProgrammaticallyScrolled.current = false;
  }, [firstSectionId, objectPageRef, topHeaderHeight, anchorBarHeight, headerPinned, headerContentHeight, headerCollapsed, prevTopHeaderHeight.current]);
  const programmaticallySetSection = () => {
    const currentId = selectedSectionId ?? firstSectionId;
    if (currentId !== prevSelectedSectionId.current) {
      debouncedOnSectionChange.cancel();
      isProgrammaticallyScrolled.current = true;
      setInternalSelectedSectionId(currentId);
      prevSelectedSectionId.current = currentId;
      const sections = objectPageRef.current?.querySelectorAll('section[data-component-name="ObjectPageSection"]');
      const currentIndex = safeGetChildrenArray(children).findIndex(objectPageSection => {
        return /*#__PURE__*/isValidElement(objectPageSection) && objectPageSection.props?.id === currentId;
      });
      fireOnSelectedChangedEvent({}, currentIndex, currentId, sections[0]);
    }
  };

  // change selected section when prop is changed (external change)
  const prevSelectedSectionId = useRef();
  const [timeStamp, setTimeStamp] = useState(0);
  const requestAnimationFrameRef = useRef();
  useEffect(() => {
    if (selectedSectionId) {
      if (mode === ObjectPageMode.Default) {
        // wait for DOM draw, otherwise initial scroll won't work as intended
        if (timeStamp < 750 && timeStamp !== undefined) {
          requestAnimationFrameRef.current = requestAnimationFrame(internalTimestamp => {
            setTimeStamp(internalTimestamp);
          });
        } else {
          setTimeStamp(undefined);
          programmaticallySetSection();
        }
      } else {
        programmaticallySetSection();
      }
    }
    return () => {
      cancelAnimationFrame(requestAnimationFrameRef.current);
    };
  }, [timeStamp, selectedSectionId, firstSectionId, debouncedOnSectionChange]);

  // section was selected by clicking on the tab bar buttons
  const handleOnSectionSelected = useCallback((targetEvent, newSelectionSectionId, index, section) => {
    isProgrammaticallyScrolled.current = true;
    debouncedOnSectionChange.cancel();
    setInternalSelectedSectionId(oldSelectedSection => {
      if (oldSelectedSection === newSelectionSectionId) {
        scrollToSection(newSelectionSectionId);
      }
      return newSelectionSectionId;
    });
    scrollEvent.current = targetEvent;
    fireOnSelectedChangedEvent(targetEvent, index, newSelectionSectionId, section);
  }, [onSelectedSectionChange, setInternalSelectedSectionId, isProgrammaticallyScrolled, scrollToSection]);

  // do internal scrolling
  useEffect(() => {
    if (mode === ObjectPageMode.Default && isProgrammaticallyScrolled.current === true && !selectedSubSectionId) {
      scrollToSection(internalSelectedSectionId);
    }
  }, [internalSelectedSectionId, mode, isProgrammaticallyScrolled, scrollToSection, selectedSubSectionId]);

  // Scrolling for Sub Section Selection
  useEffect(() => {
    if (selectedSubSectionId && isProgrammaticallyScrolled.current === true) {
      const currentSubSection = objectPageRef.current?.querySelector(`div[id="ObjectPageSubSection-${selectedSubSectionId}"]`);
      const childOffset = currentSubSection?.offsetTop;
      if (!isNaN(childOffset)) {
        currentSubSection.focus({
          preventScroll: true
        });
        objectPageRef.current?.scrollTo({
          top: childOffset - topHeaderHeight - anchorBarHeight - 48 /*tabBar*/ - (headerPinned ? headerContentHeight : 0) - 16,
          behavior: 'smooth'
        });
      }
      isProgrammaticallyScrolled.current = false;
    }
  }, [selectedSubSectionId, isProgrammaticallyScrolled.current, topHeaderHeight, anchorBarHeight, headerPinned, headerContentHeight]);
  useEffect(() => {
    if (alwaysShowContentHeader !== undefined) {
      setHeaderPinned(alwaysShowContentHeader);
    }
    if (alwaysShowContentHeader) {
      onToggleHeaderContentVisibility({
        detail: {
          visible: true
        }
      });
    }
  }, [alwaysShowContentHeader]);
  const prevHeaderPinned = useRef(headerPinned);
  useEffect(() => {
    if (prevHeaderPinned.current && !headerPinned && objectPageRef.current.scrollTop > topHeaderHeight) {
      onToggleHeaderContentVisibility({
        detail: {
          visible: false
        }
      });
      prevHeaderPinned.current = false;
    }
    if (!prevHeaderPinned.current && headerPinned) {
      prevHeaderPinned.current = true;
    }
  }, [headerPinned, topHeaderHeight]);
  useEffect(() => {
    setSelectedSubSectionId(props.selectedSubSectionId);
    if (props.selectedSubSectionId) {
      isProgrammaticallyScrolled.current = true;
      if (mode === ObjectPageMode.IconTabBar) {
        let sectionId;
        safeGetChildrenArray(children).forEach(section => {
          if ( /*#__PURE__*/isValidElement(section) && section.props && section.props.children) {
            safeGetChildrenArray(section.props.children).forEach(subSection => {
              if ( /*#__PURE__*/isValidElement(subSection) && subSection.props && subSection.props.id === props.selectedSubSectionId) {
                sectionId = section.props?.id;
              }
            });
          }
        });
        if (sectionId) {
          setInternalSelectedSectionId(sectionId);
        }
      }
    }
  }, [props.selectedSubSectionId, setInternalSelectedSectionId, setSelectedSubSectionId, children, mode]);
  useEffect(() => {
    const objectPage = objectPageRef.current;
    const sections = objectPage.querySelectorAll('[id^="ObjectPageSection"]');
    const section = sections[sections.length - 1];
    const observer = new ResizeObserver(_ref => {
      let [sectionElement] = _ref;
      let heightDiff = 0;
      if (objectPage.scrollHeight === objectPage.offsetHeight) {
        heightDiff = Math.max(objectPage.getBoundingClientRect().bottom - sectionElement.target.getBoundingClientRect().bottom, 0);
      }
      const subSections = section.querySelectorAll('[id^="ObjectPageSubSection"]');
      const lastSubSection = subSections[subSections.length - 1];
      if (lastSubSection) {
        heightDiff += objectPage.getBoundingClientRect().height - topHeaderHeight - 48 /*tabBar*/ - (!headerCollapsed ? headerContentHeight : 0) - lastSubSection.getBoundingClientRect().height - 32;
      }
      // heightDiff - footer - tabbar
      setSpacerBottomHeight(footer ? `calc(${heightDiff}px - 1rem - 48px)` : `${heightDiff}px`);
    });
    if (objectPage && section) {
      observer.observe(section, {
        box: 'border-box'
      });
    }
    return () => {
      observer.disconnect();
    };
  }, [footer, headerCollapsed, topHeaderHeight, headerContentHeight]);
  const onToggleHeaderContentVisibility = useCallback(e => {
    isToggledRef.current = true;
    scrollTimeout.current = performance.now() + 500;
    if (!e.detail.visible) {
      setHeaderCollapsedInternal(true);
      objectPageRef.current?.classList.add(classes.headerCollapsed);
    } else {
      setHeaderCollapsedInternal(false);
      setScrolledHeaderExpanded(true);
      objectPageRef.current?.classList.remove(classes.headerCollapsed);
    }
  }, []);
  const handleOnSubSectionSelected = useCallback(e => {
    isProgrammaticallyScrolled.current = true;
    if (mode === ObjectPageMode.IconTabBar) {
      const sectionId = e.detail.sectionId;
      setInternalSelectedSectionId(sectionId);
      const sections = objectPageRef.current?.querySelectorAll('section[data-component-name="ObjectPageSection"]');
      const currentIndex = safeGetChildrenArray(children).findIndex(objectPageSection => {
        return /*#__PURE__*/isValidElement(objectPageSection) && objectPageSection.props?.id === sectionId;
      });
      debouncedOnSectionChange(e, currentIndex, sectionId, sections[currentIndex]);
    }
    const subSectionId = e.detail.subSectionId;
    setSelectedSubSectionId(subSectionId);
  }, [mode, setInternalSelectedSectionId, setSelectedSubSectionId, isProgrammaticallyScrolled, children]);
  const objectPageClasses = clsx(classes.objectPage, GlobalStyleClasses.sapScrollBar, className, mode === ObjectPageMode.IconTabBar && classes.iconTabBarMode);
  const {
    onScroll: _0,
    selectedSubSectionId: _1,
    ...propsWithoutOmitted
  } = rest;
  useEffect(() => {
    const sections = objectPageRef.current?.querySelectorAll('section[data-component-name="ObjectPageSection"]');
    const objectPageHeight = objectPageRef.current?.clientHeight ?? 1000;
    const marginBottom = objectPageHeight - totalHeaderHeight - /*TabContainer*/48;
    const rootMargin = `-${totalHeaderHeight}px 0px -${marginBottom < 0 ? 0 : marginBottom}px 0px`;
    const observer = new IntersectionObserver(_ref2 => {
      let [section] = _ref2;
      if (section.isIntersecting && isProgrammaticallyScrolled.current === false) {
        if (objectPageRef.current.getBoundingClientRect().top + totalHeaderHeight + 48 <= section.target.getBoundingClientRect().bottom) {
          const currentId = extractSectionIdFromHtmlId(section.target.id);
          setInternalSelectedSectionId(currentId);
          const currentIndex = safeGetChildrenArray(children).findIndex(objectPageSection => {
            return /*#__PURE__*/isValidElement(objectPageSection) && objectPageSection.props?.id === currentId;
          });
          debouncedOnSectionChange(scrollEvent.current, currentIndex, currentId, section.target);
        }
      }
    }, {
      root: objectPageRef.current,
      rootMargin,
      threshold: [0]
    });
    // Fallback when scrolling faster than the IntersectionObserver can observe (in most cases faster than 60fps)
    if (isAfterScroll) {
      let currentSection = sections[sections.length - 1];
      let currentIndex;
      for (let i = 0; i <= sections.length - 1; i++) {
        const section = sections[i];
        if (objectPageRef.current.getBoundingClientRect().top + totalHeaderHeight + 48 <= section.getBoundingClientRect().bottom) {
          currentSection = section;
          currentIndex = i;
          break;
        }
      }
      const currentSectionId = extractSectionIdFromHtmlId(currentSection?.id);
      if (currentSectionId !== internalSelectedSectionId) {
        setInternalSelectedSectionId(currentSectionId);
        debouncedOnSectionChange(scrollEvent.current, currentIndex ?? sections.length - 1, currentSectionId, currentSection);
      }
      setIsAfterScroll(false);
    }
    sections.forEach(el => {
      observer.observe(el);
    });
    return () => {
      observer.disconnect();
    };
  }, [objectPageRef.current, children, totalHeaderHeight, setInternalSelectedSectionId, isProgrammaticallyScrolled, isAfterScroll]);
  const titleHeaderNotClickable = alwaysShowContentHeader && !headerContentPinnable || !headerContent || !showHideHeaderButton && !headerContentPinnable;
  const onTitleClick = useCallback(e => {
    e.stopPropagation();
    if (!titleHeaderNotClickable) {
      onToggleHeaderContentVisibility(enrichEventWithDetails(e, {
        visible: headerCollapsed
      }));
    }
  }, [onToggleHeaderContentVisibility, headerCollapsed, titleHeaderNotClickable]);
  const renderTitleSection = useCallback(function () {
    let inHeader = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
    const titleStyles = {
      ...(inHeader ? {
        padding: 0
      } : {}),
      ...(headerTitle?.props?.style ?? {})
    };
    if (headerTitle?.props && headerTitle.props?.showSubHeaderRight === undefined) {
      return /*#__PURE__*/cloneElement(headerTitle, {
        showSubHeaderRight: true,
        style: titleStyles,
        'data-not-clickable': titleHeaderNotClickable,
        onToggleHeaderContentVisibility: onTitleClick
      });
    }
    return /*#__PURE__*/cloneElement(headerTitle, {
      style: titleStyles,
      'data-not-clickable': titleHeaderNotClickable,
      onToggleHeaderContentVisibility: onTitleClick
    });
  }, [headerTitle, titleHeaderNotClickable, onTitleClick]);
  const renderHeaderContentSection = useCallback(() => {
    if (headerContent?.props) {
      return /*#__PURE__*/cloneElement(headerContent, {
        ...headerContent.props,
        topHeaderHeight,
        style: headerCollapsed === true ? {
          position: 'absolute',
          visibility: 'hidden'
        } : headerContent.props.style,
        headerPinned: headerPinned || scrolledHeaderExpanded,
        ref: componentRefHeaderContent,
        children: /*#__PURE__*/React.createElement("div", {
          className: classes.headerContainer,
          "data-component-name": "ObjectPageHeaderContainer"
        }, avatar, headerContent.props.children && /*#__PURE__*/React.createElement("div", {
          "data-component-name": "ObjectPageHeaderContent"
        }, headerTitle && showTitleInHeaderContent && renderTitleSection(true), headerContent.props.children))
      });
    }
  }, [headerContent, topHeaderHeight, headerPinned, scrolledHeaderExpanded, showTitleInHeaderContent, avatar, headerContentRef, renderTitleSection]);
  const onTabItemSelect = event => {
    event.preventDefault();
    const {
      sectionId,
      index,
      isSubTab,
      parentId
    } = event.detail.tab.dataset;
    if (isSubTab) {
      handleOnSubSectionSelected(enrichEventWithDetails(event, {
        sectionId: parentId,
        subSectionId: sectionId
      }));
    } else {
      const section = safeGetChildrenArray(children).find(el => {
        return el.props.id == sectionId;
      });
      handleOnSectionSelected(event, section?.props?.id, index, section);
    }
  };
  const prevScrollTop = useRef();
  const onObjectPageScroll = useCallback(e => {
    if (!isToggledRef.current) {
      isToggledRef.current = true;
    }
    if (scrollTimeout.current >= performance.now()) {
      return;
    }
    scrollEvent.current = e;
    if (typeof props.onScroll === 'function') {
      props.onScroll(e);
    }
    if (selectedSubSectionId) {
      setSelectedSubSectionId(undefined);
    }
    if (selectionScrollTimeout.current) {
      clearTimeout(selectionScrollTimeout.current);
    }
    selectionScrollTimeout.current = setTimeout(() => {
      setIsAfterScroll(true);
    }, 100);
    if (!headerPinned || e.target.scrollTop === 0) {
      objectPageRef.current?.classList.remove(classes.headerCollapsed);
    }
    if (scrolledHeaderExpanded && e.target.scrollTop !== prevScrollTop.current) {
      if (e.target.scrollHeight - e.target.scrollTop === e.target.clientHeight) {
        return;
      }
      prevScrollTop.current = e.target.scrollTop;
      if (!headerPinned) {
        setHeaderCollapsedInternal(true);
      }
      setScrolledHeaderExpanded(false);
    }
  }, [topHeaderHeight, headerPinned, props.onScroll, scrolledHeaderExpanded, selectedSubSectionId]);
  const onHoverToggleButton = useCallback(e => {
    if (e?.type === 'mouseover') {
      topHeaderRef.current?.classList.add(classes.headerHoverStyles);
    } else {
      topHeaderRef.current?.classList.remove(classes.headerHoverStyles);
    }
  }, [classes.headerHoverStyles]);
  const objectPageStyles = {
    ...style
  };
  if (headerCollapsed === true && headerContent) {
    objectPageStyles[DynamicPageCssVariables.titleFontSize] = ThemingParameters.sapObjectHeader_Title_SnappedFontSize;
  }
  return /*#__PURE__*/React.createElement("div", {
    "data-component-name": "ObjectPage",
    slot: slot,
    className: objectPageClasses,
    style: objectPageStyles,
    ref: componentRef,
    onScroll: onObjectPageScroll,
    ...propsWithoutOmitted
  }, /*#__PURE__*/React.createElement("header", {
    onMouseOver: onHoverToggleButton,
    onMouseLeave: onHoverToggleButton,
    "data-component-name": "ObjectPageTopHeader",
    ref: topHeaderRef,
    role: a11yConfig?.objectPageTopHeader?.role ?? 'banner',
    "data-not-clickable": titleHeaderNotClickable,
    "aria-roledescription": a11yConfig?.objectPageTopHeader?.ariaRoledescription ?? 'Object Page header',
    className: classes.header,
    onClick: onTitleClick,
    style: {
      gridAutoColumns: `min-content ${headerTitle && image && headerCollapsed === true ? `calc(100% - 3rem - 1rem)` : '100%'}`,
      display: !showTitleInHeaderContent || headerCollapsed === true ? 'grid' : 'none'
    }
  }, headerTitle && image && headerCollapsed === true && /*#__PURE__*/React.createElement(CollapsedAvatar, {
    image: image,
    imageShapeCircle: imageShapeCircle
  }), headerTitle && renderTitleSection()), renderHeaderContentSection(), headerContent && headerTitle && /*#__PURE__*/React.createElement("div", {
    "data-component-name": "ObjectPageAnchorBar",
    ref: anchorBarRef,
    className: classes.anchorBar,
    style: {
      top: scrolledHeaderExpanded || headerPinned ? `${topHeaderHeight + (headerCollapsed === true ? 0 : headerContentHeight)}px` : `${topHeaderHeight + 5}px`
    }
  }, /*#__PURE__*/React.createElement(DynamicPageAnchorBar, {
    headerContentVisible: headerContent && headerCollapsed !== true,
    headerContentPinnable: headerContentPinnable,
    showHideHeaderButton: showHideHeaderButton,
    headerPinned: headerPinned,
    a11yConfig: a11yConfig,
    onToggleHeaderContentVisibility: onToggleHeaderContentVisibility,
    setHeaderPinned: setHeaderPinned,
    onHoverToggleButton: onHoverToggleButton,
    onPinnedStateChange: onPinnedStateChange
  })), !placeholder && /*#__PURE__*/React.createElement("div", {
    className: classes.tabContainer,
    "data-component-name": "ObjectPageTabContainer",
    style: {
      top: headerPinned || scrolledHeaderExpanded ? `${topHeaderHeight + (headerCollapsed === true ? 0 : headerContentHeight)}px` : `${topHeaderHeight}px`
    }
  }, /*#__PURE__*/React.createElement(TabContainer, {
    collapsed: true,
    fixed: true,
    onTabSelect: onTabItemSelect,
    "data-component-name": "ObjectPageTabContainer",
    className: classes.tabContainerComponent
  }, safeGetChildrenArray(children).map((section, index) => {
    if (! /*#__PURE__*/isValidElement(section) || !section.props) return null;
    const subTabs = safeGetChildrenArray(section.props.children).filter(subSection =>
    // @ts-expect-error: if the `ObjectPageSubSection` component is passed as children, the `displayName` is available. Otherwise, the default children should be rendered w/o additional logic.
    /*#__PURE__*/isValidElement(subSection) && subSection?.type?.displayName === 'ObjectPageSubSection');
    return /*#__PURE__*/React.createElement(Tab, {
      key: `Anchor-${section.props?.id}`,
      "data-index": index,
      "data-section-id": section.props.id,
      text: section.props.titleText,
      selected: internalSelectedSectionId === section.props?.id || undefined,
      subTabs: subTabs.map(item => {
        if (! /*#__PURE__*/isValidElement(item)) {
          return null;
        }
        return /*#__PURE__*/React.createElement(Tab, {
          "data-parent-id": section.props.id,
          key: item.props.id,
          "data-is-sub-tab": true,
          "data-section-id": item.props.id,
          text: item.props.titleText,
          selected: item.props.id === selectedSubSectionId || undefined
        }, /*#__PURE__*/React.createElement("span", {
          style: {
            display: 'none'
          }
        }));
      })
    }, /*#__PURE__*/React.createElement("span", {
      style: {
        display: 'none'
      }
    }));
  }))), /*#__PURE__*/React.createElement("div", {
    "data-component-name": "ObjectPageContent",
    className: classes.content
  }, /*#__PURE__*/React.createElement("div", {
    style: {
      height: headerCollapsed ? `${headerContentHeight}px` : 0
    },
    "aria-hidden": "true"
  }), placeholder ? placeholder : mode === ObjectPageMode.IconTabBar ? getSectionById(children, internalSelectedSectionId) : children, /*#__PURE__*/React.createElement("div", {
    style: {
      height: spacerBottomHeight
    },
    "aria-hidden": "true"
  })), footer && /*#__PURE__*/React.createElement("div", {
    style: {
      height: '1rem'
    },
    "data-component-name": "ObjectPageFooterSpacer"
  }), footer && /*#__PURE__*/React.createElement("footer", {
    className: classes.footer,
    "data-component-name": "ObjectPageFooter"
  }, footer));
});
ObjectPage.displayName = 'ObjectPage';
ObjectPage.defaultProps = {
  image: null,
  mode: ObjectPageMode.Default,
  imageShapeCircle: false,
  showHideHeaderButton: false
};
export { ObjectPage };