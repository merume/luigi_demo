'use client';

import { useVirtualizer } from '@tanstack/react-virtual';
import { debounce, enrichEventWithDetails, useI18nBundle, useIsomorphicId, useIsomorphicLayoutEffect, useIsRTL } from '@ui5/webcomponents-react-base';
import { clsx } from 'clsx';
import React, { forwardRef, useCallback, useEffect, useMemo, useRef } from 'react';
import { createUseStyles } from 'react-jss';
import { useColumnOrder, useExpanded, useFilters, useGlobalFilter, useGroupBy, useResizeColumns, useRowSelect, useSortBy, useTable } from 'react-table';
import { AnalyticalTableScaleWidthMode, AnalyticalTableSelectionBehavior, AnalyticalTableVisibleRowCountMode, GlobalStyleClasses, AnalyticalTableSelectionMode } from '../../enums';
import { COLLAPSE_NODE, COLLAPSE_PRESS_SPACE, EXPAND_NODE, EXPAND_PRESS_SPACE, FILTERED, GROUPED, INVALID_TABLE, SELECT_PRESS_SPACE, UNSELECT_PRESS_SPACE } from '../../i18n/i18n-defaults';
import { FlexBox } from '../FlexBox';
import { Text } from '../Text';
import styles from './AnayticalTable.jss';
import { ColumnHeaderContainer } from './ColumnHeader/ColumnHeaderContainer';
import { DefaultColumn } from './defaults/Column';
import { DefaultLoadingComponent } from './defaults/LoadingComponent';
import { TablePlaceholder } from './defaults/LoadingComponent/TablePlaceholder';
import { DefaultNoDataComponent } from './defaults/NoDataComponent';
import { useA11y } from './hooks/useA11y';
import { useDragAndDrop } from './hooks/useDragAndDrop';
import { useDynamicColumnWidths } from './hooks/useDynamicColumnWidths';
import { useKeyboardNavigation } from './hooks/useKeyboardNavigation';
import { usePopIn } from './hooks/usePopIn';
import { useResizeColumnsConfig } from './hooks/useResizeColumnsConfig';
import { useRowHighlight } from './hooks/useRowHighlight';
import { useRowNavigationIndicators } from './hooks/useRowNavigationIndicator';
import { useRowSelectionColumn } from './hooks/useRowSelectionColumn';
import { useSelectionChangeCallback } from './hooks/useSelectionChangeCallback';
import { useSingleRowStateSelection } from './hooks/useSingleRowStateSelection';
import { useStyling } from './hooks/useStyling';
import { useTableScrollHandles } from './hooks/useTableScrollHandles';
import { useToggleRowExpand } from './hooks/useToggleRowExpand';
import { useVisibleColumnsWidth } from './hooks/useVisibleColumnsWidth';
import { VerticalScrollbar } from './scrollbars/VerticalScrollbar';
import { VirtualTableBody } from './TableBody/VirtualTableBody';
import { VirtualTableBodyContainer } from './TableBody/VirtualTableBodyContainer';
import { stateReducer } from './tableReducer/stateReducer';
import { TitleBar } from './TitleBar';
import { getRowHeight, tagNamesWhichShouldNotSelectARow } from './util';
import { VerticalResizer } from './VerticalResizer';
// When a sorted column is removed from the visible columns array (e.g. when "popped-in"), it doesn't clean up the sorted columns leading to an undefined `sortType`.
const sortTypesFallback = {
  undefined: () => undefined
};
const useStyles = createUseStyles(styles, {
  name: 'AnalyticalTable'
});
/**
 * The `AnalyticalTable` provides a set of convenient functions for responsive table design, including virtualization of rows and columns, infinite scrolling and customizable columns that will, unless otherwise defined, distribute the available space equally among themselves.
 * It also provides several possibilities for working with the data, including sorting, filtering, grouping and aggregation.
 */
const AnalyticalTable = /*#__PURE__*/forwardRef((props, ref) => {
  const {
    alternateRowColor,
    alwaysShowSubComponent,
    adjustTableHeightOnPopIn,
    className,
    columnOrder,
    columns,
    data: rawData,
    extension,
    filterable,
    globalFilterValue,
    groupBy,
    groupable,
    header,
    headerRowHeight,
    highlightField,
    infiniteScroll,
    infiniteScrollThreshold,
    isTreeTable,
    loading,
    markNavigatedRow,
    minRows,
    noDataText,
    overscanCount,
    overscanCountHorizontal,
    portalContainer,
    retainColumnWidth,
    reactTableOptions,
    renderRowSubComponent,
    rowHeight,
    scaleWidthMode,
    selectedRowIds,
    selectionBehavior,
    selectionMode,
    showOverlay,
    sortable,
    style,
    subRowsKey,
    tableHooks,
    tableInstance,
    visibleRowCountMode,
    visibleRows,
    withNavigationHighlight,
    withRowHighlight,
    onColumnsReorder,
    onGroup,
    onLoadMore,
    onRowClick,
    onRowExpandChange,
    onRowSelect,
    onSort,
    onTableScroll,
    LoadingComponent,
    NoDataComponent,
    scaleXFactor,
    ...rest
  } = props;
  const uniqueId = useIsomorphicId();
  const i18nBundle = useI18nBundle('@ui5/webcomponents-react');
  const titleBarId = useRef(`titlebar-${uniqueId}`).current;
  const invalidTableTextId = useRef(`invalidTableText-${uniqueId}`).current;
  const classes = useStyles();
  const [analyticalTableRef, scrollToRef] = useTableScrollHandles(ref);
  const tableRef = useRef(null);
  const isRtl = useIsRTL(analyticalTableRef);
  const getSubRows = useCallback(row => row.subRows || row[subRowsKey] || [], [subRowsKey]);
  const invalidTableA11yText = i18nBundle.getText(INVALID_TABLE);
  const tableInstanceRef = useRef(null);
  tableInstanceRef.current = useTable({
    columns,
    data: rawData,
    defaultColumn: DefaultColumn,
    getSubRows,
    stateReducer,
    disableFilters: !filterable,
    disableSortBy: !sortable,
    disableGroupBy: isTreeTable || renderRowSubComponent ? true : !groupable,
    selectSubRows: false,
    sortTypes: sortTypesFallback,
    webComponentsReactProperties: {
      translatableTexts: {
        expandA11yText: i18nBundle.getText(EXPAND_PRESS_SPACE),
        collapseA11yText: i18nBundle.getText(COLLAPSE_PRESS_SPACE),
        selectA11yText: i18nBundle.getText(SELECT_PRESS_SPACE),
        unselectA11yText: i18nBundle.getText(UNSELECT_PRESS_SPACE),
        expandNodeA11yText: i18nBundle.getText(EXPAND_NODE),
        collapseNodeA11yText: i18nBundle.getText(COLLAPSE_NODE),
        filteredA11yText: i18nBundle.getText(FILTERED),
        groupedA11yText: i18nBundle.getText(GROUPED)
      },
      tagNamesWhichShouldNotSelectARow,
      tableRef,
      selectionMode,
      selectionBehavior,
      classes,
      onRowSelect: onRowSelect,
      onRowClick,
      onRowExpandChange,
      isTreeTable,
      alternateRowColor,
      scaleWidthMode,
      loading,
      withRowHighlight,
      highlightField,
      withNavigationHighlight,
      markNavigatedRow,
      renderRowSubComponent,
      alwaysShowSubComponent,
      scrollToRef,
      showOverlay,
      uniqueId,
      scaleXFactor
    },
    ...reactTableOptions
  }, useFilters, useGlobalFilter, useColumnOrder, useGroupBy, useSortBy, useExpanded, useRowSelect, useResizeColumns, useResizeColumnsConfig, useRowSelectionColumn, useSingleRowStateSelection, useSelectionChangeCallback, useRowHighlight, useRowNavigationIndicators, useDynamicColumnWidths, useStyling, useToggleRowExpand, useA11y, usePopIn, useVisibleColumnsWidth, useKeyboardNavigation, ...tableHooks);
  const {
    getTableProps,
    headerGroups,
    rows,
    prepareRow,
    state: tableState,
    columns: tableInternalColumns,
    setColumnOrder,
    dispatch,
    totalColumnsWidth,
    visibleColumns,
    visibleColumnsWidth,
    setGroupBy,
    setGlobalFilter
  } = tableInstanceRef.current;
  if (tableInstance && {}.hasOwnProperty.call(tableInstance, 'current')) {
    tableInstance.current = tableInstanceRef.current;
  }
  if (typeof tableInstance === 'function') {
    tableInstance(tableInstanceRef.current);
  }
  const titleBarRef = useRef(null);
  const extensionRef = useRef(null);
  const headerRef = useRef(null);
  const extensionsHeight = (titleBarRef.current?.offsetHeight ?? 0) + (extensionRef.current?.offsetHeight ?? 0) + (headerRef.current?.offsetHeight ?? 0);
  const internalRowHeight = getRowHeight(rowHeight, tableRef);
  const internalHeaderRowHeight = headerRowHeight ?? internalRowHeight;
  const popInRowHeight = tableState?.popInColumns?.length > 0 ? internalRowHeight + tableState.popInColumns.length * (internalRowHeight + 16) : internalRowHeight;
  const internalVisibleRowCount = tableState.visibleRows ?? visibleRows;
  const updateTableClientWidth = useCallback(() => {
    if (tableRef.current) {
      dispatch({
        type: 'TABLE_RESIZE',
        payload: {
          tableClientWidth: tableRef.current.clientWidth
        }
      });
    }
  }, [tableRef.current]);
  const updateRowsCount = useCallback(() => {
    if (visibleRowCountMode === AnalyticalTableVisibleRowCountMode.Auto && analyticalTableRef.current?.parentElement) {
      const parentElement = analyticalTableRef.current?.parentElement;
      const tableYPosition = parentElement && getComputedStyle(parentElement).position === 'relative' && analyticalTableRef.current?.offsetTop ? analyticalTableRef.current?.offsetTop : 0;
      const parentHeight = parentElement?.getBoundingClientRect().height;
      const tableHeight = parentHeight ? parentHeight - tableYPosition : 0;
      const rowCount = Math.max(1, Math.floor((tableHeight - extensionsHeight) / popInRowHeight));
      dispatch({
        type: 'VISIBLE_ROWS',
        payload: {
          visibleRows: rowCount
        }
      });
    }
  }, [analyticalTableRef.current?.parentElement?.getBoundingClientRect().height, analyticalTableRef.current?.getBoundingClientRect().y, extensionsHeight, popInRowHeight, visibleRowCountMode]);
  useEffect(() => {
    setGlobalFilter(globalFilterValue);
  }, [globalFilterValue, setGlobalFilter]);
  useEffect(() => {
    const debouncedWidthObserverFn = debounce(updateTableClientWidth, 60);
    const tableWidthObserver = new ResizeObserver(debouncedWidthObserverFn);
    tableWidthObserver.observe(tableRef.current);
    const debouncedHeightObserverFn = debounce(updateRowsCount, 60);
    const parentHeightObserver = new ResizeObserver(debouncedHeightObserverFn);
    if (analyticalTableRef.current?.parentElement) {
      parentHeightObserver.observe(analyticalTableRef.current?.parentElement);
    }
    return () => {
      debouncedHeightObserverFn.cancel();
      debouncedWidthObserverFn.cancel();
      tableWidthObserver.disconnect();
      parentHeightObserver.disconnect();
    };
  }, [updateTableClientWidth, updateRowsCount]);
  useIsomorphicLayoutEffect(() => {
    dispatch({
      type: 'IS_RTL',
      payload: {
        isRtl
      }
    });
  }, [isRtl]);
  useIsomorphicLayoutEffect(() => {
    updateTableClientWidth();
  }, [updateTableClientWidth]);
  useIsomorphicLayoutEffect(() => {
    updateRowsCount();
  }, [updateRowsCount]);
  useEffect(() => {
    if (tableState.visibleRows !== undefined && visibleRowCountMode === AnalyticalTableVisibleRowCountMode.Fixed) {
      dispatch({
        type: 'VISIBLE_ROWS',
        payload: {
          visibleRows: undefined
        }
      });
    }
  }, [visibleRowCountMode, tableState.visibleRows]);
  useEffect(() => {
    setGroupBy(groupBy);
  }, [groupBy, setGroupBy]);
  useEffect(() => {
    dispatch({
      type: 'SET_SELECTED_ROW_IDS',
      payload: {
        selectedRowIds
      }
    });
  }, [selectedRowIds]);
  useEffect(() => {
    if (tableState?.interactiveRowsHavePopIn && (!tableState?.popInColumns || tableState?.popInColumns?.length === 0)) {
      dispatch({
        type: 'WITH_POPIN',
        payload: false
      });
    }
  }, [tableState?.interactiveRowsHavePopIn, tableState?.popInColumns?.length]);
  const tableBodyHeight = useMemo(() => {
    const rowNum = rows.length < internalVisibleRowCount ? Math.max(rows.length, minRows) : internalVisibleRowCount;
    const rowHeight = visibleRowCountMode === AnalyticalTableVisibleRowCountMode.Auto || tableState?.interactiveRowsHavePopIn || adjustTableHeightOnPopIn ? popInRowHeight : internalRowHeight;
    return rowHeight * rowNum;
  }, [internalRowHeight, rows.length, internalVisibleRowCount, minRows, popInRowHeight, visibleRowCountMode, tableState?.interactiveRowsHavePopIn, adjustTableHeightOnPopIn]);

  // scroll bar detection
  useEffect(() => {
    const visibleRowCount = rows.length < internalVisibleRowCount ? Math.max(rows.length, minRows) : internalVisibleRowCount;
    if (popInRowHeight !== internalRowHeight) {
      dispatch({
        type: 'TABLE_SCROLLING_ENABLED',
        payload: {
          isScrollable: visibleRowCount * popInRowHeight > tableBodyHeight || rows.length > visibleRowCount
        }
      });
    } else {
      dispatch({
        type: 'TABLE_SCROLLING_ENABLED',
        payload: {
          isScrollable: rows.length > visibleRowCount
        }
      });
    }
  }, [rows.length, minRows, internalVisibleRowCount, popInRowHeight, tableBodyHeight]);
  const noDataStyles = {
    height: `${tableBodyHeight}px`,
    width: totalColumnsWidth ? `${totalColumnsWidth}px` : '100%'
  };
  const onGroupByChanged = useCallback(e => {
    const {
      column,
      isGrouped
    } = e.detail;
    let groupedColumns = [];
    if (isGrouped) {
      groupedColumns = [...tableState.groupBy, column.id];
    } else {
      groupedColumns = tableState.groupBy.filter(group => group !== column.id);
    }
    setGroupBy(groupedColumns);
    onGroup(enrichEventWithDetails(e, {
      column,
      groupedColumns
    }));
  }, [tableState.groupBy, onGroup, setGroupBy]);
  useEffect(() => {
    if (columnOrder?.length > 0) {
      setColumnOrder(columnOrder);
    }
  }, [columnOrder]);
  const [dragOver, handleDragEnter, handleDragStart, handleDragOver, handleOnDrop, handleOnDragEnd] = useDragAndDrop(isRtl, setColumnOrder, tableState.columnOrder, tableState.columnResizing, tableInternalColumns, onColumnsReorder);
  const inlineStyle = useMemo(() => {
    const tableStyles = {
      maxWidth: '100%',
      overflowX: 'auto',
      display: 'flex',
      flexDirection: 'column'
    };
    if (!!rowHeight) {
      tableStyles['--sapWcrAnalyticalTableRowHeight'] = `${rowHeight}px`;
      tableStyles['--sapWcrAnalyticalTableHeaderRowHeight'] = `${rowHeight}px`;
    }
    if (!!headerRowHeight) {
      tableStyles['--sapWcrAnalyticalTableHeaderRowHeight'] = `${headerRowHeight}px`;
    }
    if (tableState.tableClientWidth > 0) {
      return {
        ...tableStyles,
        ...style
      };
    }
    return {
      ...tableStyles,
      ...style,
      visibility: 'hidden'
    };
  }, [tableState.tableClientWidth, style, rowHeight, headerRowHeight]);
  useEffect(() => {
    if (retainColumnWidth && tableState.columnResizing?.isResizingColumn && tableState.tableColResized == null) {
      dispatch({
        type: 'TABLE_COL_RESIZED',
        payload: true
      });
    }
    if (tableState.tableColResized && !retainColumnWidth) {
      dispatch({
        type: 'TABLE_COL_RESIZED',
        payload: undefined
      });
    }
  }, [tableState.columnResizing, retainColumnWidth, tableState.tableColResized]);
  const parentRef = useRef(null);
  const verticalScrollBarRef = useRef(null);
  const handleBodyScroll = e => {
    if (typeof onTableScroll === 'function') {
      onTableScroll(e);
    }
    if (verticalScrollBarRef.current && verticalScrollBarRef.current.scrollTop !== parentRef.current.scrollTop) {
      if (!parentRef.current.isExternalVerticalScroll) {
        verticalScrollBarRef.current.scrollTop = parentRef.current.scrollTop;
        verticalScrollBarRef.current.isExternalVerticalScroll = true;
      }
      parentRef.current.isExternalVerticalScroll = false;
    }
  };
  const handleVerticalScrollBarScroll = () => {
    if (!verticalScrollBarRef.current.isExternalVerticalScroll) {
      parentRef.current.scrollTop = verticalScrollBarRef.current.scrollTop;
      parentRef.current.isExternalVerticalScroll = true;
    }
    verticalScrollBarRef.current.isExternalVerticalScroll = false;
  };
  const tableClasses = clsx(classes.table, GlobalStyleClasses.sapScrollBar, withNavigationHighlight && classes.hasNavigationIndicator);
  const columnVirtualizer = useVirtualizer({
    count: visibleColumnsWidth.length,
    getScrollElement: () => tableRef.current,
    estimateSize: useCallback(index => {
      return visibleColumnsWidth[index];
    }, [visibleColumnsWidth]),
    horizontal: true,
    overscan: overscanCountHorizontal
  });
  scrollToRef.current = {
    ...scrollToRef.current,
    horizontalScrollToOffset: columnVirtualizer.scrollToOffset,
    horizontalScrollToIndex: columnVirtualizer.scrollToIndex
  };
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
    className: className,
    style: inlineStyle,
    ref: analyticalTableRef,
    ...rest
  }, header && /*#__PURE__*/React.createElement(TitleBar, {
    ref: titleBarRef,
    titleBarId: titleBarId
  }, header), extension && /*#__PURE__*/React.createElement("div", {
    ref: extensionRef
  }, extension), /*#__PURE__*/React.createElement(FlexBox, {
    className: classes.tableContainerWithScrollBar,
    "data-component-name": "AnalyticalTableContainerWithScrollbar"
  }, showOverlay && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("span", {
    id: invalidTableTextId,
    className: classes.hiddenA11yText,
    "aria-hidden": true
  }, invalidTableA11yText), /*#__PURE__*/React.createElement("div", {
    tabIndex: 0,
    "aria-labelledby": `${titleBarId} ${invalidTableTextId}`,
    role: "region",
    "data-component-name": "AnalyticalTableOverlay",
    className: classes.overlay
  })), /*#__PURE__*/React.createElement("div", {
    "aria-labelledby": titleBarId,
    ...getTableProps(),
    tabIndex: showOverlay ? -1 : 0,
    role: "grid",
    "aria-rowcount": rows.length,
    "aria-colcount": visibleColumns.length,
    "data-per-page": internalVisibleRowCount,
    "data-component-name": "AnalyticalTableContainer",
    ref: tableRef,
    "data-native-scrollbar": props['data-native-scrollbar'],
    className: tableClasses
  }, /*#__PURE__*/React.createElement("div", {
    className: classes.tableHeaderBackgroundElement
  }), /*#__PURE__*/React.createElement("div", {
    className: classes.tableBodyBackgroundElement
  }), headerGroups.map(headerGroup => {
    let headerProps = {};
    if (headerGroup.getHeaderGroupProps) {
      headerProps = headerGroup.getHeaderGroupProps();
    }
    return tableRef.current && /*#__PURE__*/React.createElement(ColumnHeaderContainer, {
      ref: headerRef,
      key: headerProps.key,
      resizeInfo: tableState.columnResizing,
      headerProps: headerProps,
      headerGroup: headerGroup,
      onSort: onSort,
      onGroupByChanged: onGroupByChanged,
      onDragStart: handleDragStart,
      onDragOver: handleDragOver,
      onDrop: handleOnDrop,
      onDragEnter: handleDragEnter,
      onDragEnd: handleOnDragEnd,
      dragOver: dragOver,
      isRtl: isRtl,
      portalContainer: portalContainer,
      columnVirtualizer: columnVirtualizer,
      scaleXFactor: scaleXFactor,
      uniqueId: uniqueId
    });
  }), loading && rawData?.length > 0 && /*#__PURE__*/React.createElement(LoadingComponent, {
    style: {
      width: `${totalColumnsWidth}px`
    }
  }), loading && rawData?.length === 0 && /*#__PURE__*/React.createElement(TablePlaceholder, {
    columns: visibleColumns,
    rows: minRows,
    style: noDataStyles
  }), !loading && rawData?.length === 0 && /*#__PURE__*/React.createElement(NoDataComponent, {
    noDataText: noDataText,
    className: classes.noDataContainer,
    style: noDataStyles
  }), rawData?.length > 0 && tableRef.current && /*#__PURE__*/React.createElement(VirtualTableBodyContainer, {
    rowCollapsedFlag: tableState.rowCollapsed,
    dispatch: dispatch,
    tableBodyHeight: tableBodyHeight,
    totalColumnsWidth: totalColumnsWidth,
    parentRef: parentRef,
    classes: classes,
    infiniteScroll: infiniteScroll,
    infiniteScrollThreshold: infiniteScrollThreshold,
    onLoadMore: onLoadMore,
    internalRowHeight: internalRowHeight,
    popInRowHeight: popInRowHeight,
    rows: rows,
    handleExternalScroll: handleBodyScroll,
    visibleRows: internalVisibleRowCount
  }, /*#__PURE__*/React.createElement(VirtualTableBody, {
    classes: classes,
    prepareRow: prepareRow,
    rows: rows,
    minRows: minRows,
    scrollToRef: scrollToRef,
    isTreeTable: isTreeTable,
    internalRowHeight: internalRowHeight,
    popInRowHeight: popInRowHeight,
    visibleRows: internalVisibleRowCount,
    alternateRowColor: alternateRowColor,
    overscanCount: overscanCount,
    parentRef: parentRef,
    visibleColumns: visibleColumns,
    renderRowSubComponent: renderRowSubComponent,
    alwaysShowSubComponent: alwaysShowSubComponent,
    markNavigatedRow: markNavigatedRow,
    isRtl: isRtl,
    subComponentsHeight: tableState.subComponentsHeight,
    dispatch: dispatch,
    columnVirtualizer: columnVirtualizer
  }))), (tableState.isScrollable === undefined || tableState.isScrollable) && /*#__PURE__*/React.createElement(VerticalScrollbar, {
    tableBodyHeight: tableBodyHeight,
    internalRowHeight: internalHeaderRowHeight,
    popInRowHeight: popInRowHeight,
    tableRef: tableRef,
    minRows: minRows,
    rows: rows,
    handleVerticalScrollBarScroll: handleVerticalScrollBarScroll,
    ref: verticalScrollBarRef,
    "data-native-scrollbar": props['data-native-scrollbar']
  })), visibleRowCountMode === AnalyticalTableVisibleRowCountMode.Interactive && /*#__PURE__*/React.createElement(VerticalResizer, {
    popInRowHeight: popInRowHeight,
    hasPopInColumns: tableState?.popInColumns?.length > 0,
    analyticalTableRef: analyticalTableRef,
    dispatch: dispatch,
    extensionsHeight: extensionsHeight,
    internalRowHeight: internalRowHeight,
    portalContainer: portalContainer
  })), /*#__PURE__*/React.createElement(Text, {
    "aria-hidden": "true",
    id: `smartScaleModeHelper-${uniqueId}`,
    className: classes.hiddenSmartColMeasure
  }, ''));
});
AnalyticalTable.displayName = 'AnalyticalTable';
AnalyticalTable.defaultProps = {
  infiniteScrollThreshold: 20,
  loading: false,
  sortable: true,
  filterable: false,
  groupable: false,
  selectionMode: AnalyticalTableSelectionMode.None,
  selectionBehavior: AnalyticalTableSelectionBehavior.Row,
  scaleWidthMode: AnalyticalTableScaleWidthMode.Default,
  data: [],
  columns: [],
  minRows: 5,
  groupBy: [],
  NoDataComponent: DefaultNoDataComponent,
  LoadingComponent: DefaultLoadingComponent,
  noDataText: 'No Data',
  reactTableOptions: {},
  tableHooks: [],
  visibleRows: 15,
  subRowsKey: 'subRows',
  highlightField: 'status',
  markNavigatedRow: () => false,
  selectedRowIds: {},
  onGroup: () => {},
  onRowExpandChange: () => {},
  isTreeTable: false,
  alternateRowColor: false,
  overscanCountHorizontal: 5,
  visibleRowCountMode: AnalyticalTableVisibleRowCountMode.Fixed,
  alwaysShowSubComponent: false
};
export { AnalyticalTable };